



/*








Didula MD



⠄⠄⠄⢰⣧⣼⣯⠄⣸⣠⣶⣶⣦⣾⠄⠄⠄⠄⡀⠄⢀⣿⣿⠄⠄⠄⢸⡇⠄⠄
⠄⠄⠄⣾⣿⠿⠿⠶⠿⢿⣿⣿⣿⣿⣦⣤⣄⢀⡅⢠⣾⣛⡉⠄⠄⠄⠸⢀⣿⠄
⠄⠄⢀⡋⣡⣴⣶⣶⡀⠄⠄⠙⢿⣿⣿⣿⣿⣿⣴⣿⣿⣿⢃⣤⣄⣀⣥⣿⣿⠄
⠄⠄⢸⣇⠻⣿⣿⣿⣧⣀⢀⣠⡌⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠿⠿⣿⣿⣿⠄
⠄⢀⢸⣿⣷⣤⣤⣤⣬⣙⣛⢿⣿⣿⣿⣿⣿⣿⡿⣿⣿⡍⠄⠄⢀⣤⣄⠉⠋⣰
⠄⣼⣖⣿⣿⣿⣿⣿⣿⣿⣿⣿⢿⣿⣿⣿⣿⣿⢇⣿⣿⡷⠶⠶⢿⣿⣿⠇⢀⣤
⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣽⣿⣿⣿⡇⣿⣿⣿⣿⣿⣿⣷⣶⣥⣴⣿⡗
⢀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠄
⢸⣿⣦⣌⣛⣻⣿⣿⣧⠙⠛⠛⡭⠅⠒⠦⠭⣭⡻⣿⣿⣿⣿⣿⣿⣿⣿⡿⠃⠄
⠘⣿⣿⣿⣿⣿⣿⣿⣿⡆⠄⠄⠄⠄⠄⠄⠄⠄⠹⠈⢋⣽⣿⣿⣿⣿⣵⣾⠃⠄
⠄⠘⣿⣿⣿⣿⣿⣿⣿⣿⠄⣴⣿⣶⣄⠄⣴⣶⠄⢀⣾⣿⣿⣿⣿⣿⣿⠃⠄⠄
⠄⠄⠈⠻⣿⣿⣿⣿⣿⣿⡄⢻⣿⣿⣿⠄⣿⣿⡀⣾⣿⣿⣿⣿⣛⠛⠁⠄⠄⠄
⠄⠄⠄⠄⠈⠛⢿⣿⣿⣿⠁⠞⢿⣿⣿⡄⢿⣿⡇⣸⣿⣿⠿⠛⠁⠄⠄⠄⠄⠄
⠄⠄⠄⠄⠄⠄⠄⠉⠻⣿⣿⣾⣦⡙⠻⣷⣾⣿⠃⠿⠋⠁⠄⠄⠄⠄⠄⢀⣠⣴
⣿⣿⣿⣶⣶⣮⣥⣒⠲⢮⣝⡿⣿⣿⡆⣿⡿⠃⠄⠄⠄⠄⠄⠄⠄⣠⣴⣿⣿⣿

̶ ̶ ̶͟͞ ̶͟͞ ̶͟͞ ̶🍃:𝗜 𝗙𝗨𝗖𝗞𝝣𝗗 𝗬𝝧𝗨𝗥 𝗗𝝣𝗩𝗜𝗖𝝣:|🍃 ͟͞

===============

Didula Rashmika 




*/













































// =============================================================









const { cmd, commands } = require('../lib/command');
const scraper = require("../lib/scraperd");
const axios = require('axios');
const fetch = require('node-fetch');
const { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, runtime, sleep, fetchJson} = require('../lib/functions')
var { updateCMDStore,isbtnID,getCMDStore,getCmdForCmdId,connectdb,input,get,updb,updfb } = require("../lib/database")

var { get_set , input_set } = require('../lib/set_db')        
// ======================✅💗

const { lookup } = require('mime-types');
const fs = require('fs');
const path = require('path');
const yts = require('yt-search'); // For YouTube search
const cheerio = require('cheerio'); // Import cheerio for HTML parsing

const { ytsearch, ytmp3, ytmp4 } = require('@dark-yasiya/yt-dl.js'); 
const config = require('../settings')
const xml2js = require('xml2js');
const { updateEnv, readEnv } = require('../lib/database');
const os = require("os")
// 😂🌝ආආ හම්බුන්දා 😁😁😁😁
// 🌝ලස්සනයි ලස්සනයි 🌝
const { BufferJSON, WA_DEFAULT_EPHEMERAL, generateWAMessageFromContent, proto, generateWAMessageContent, generateWAMessage, prepareWAMessageMedia, downloadContentFromMessage, areJidsSameUser, getContentType } = require('@whiskeysockets/baileys')
const { igdl } = require('ruhend-scraper');

const si = require('systeminformation');
const pdfUrl = "https://i.ibb.co/tC37Q7B/20241220-122443.jpg";
const g_i_s = require('g-i-s');
let { img2url } = require('@blackamda/telegram-image-url');

const {Sticker, createSticker, StickerTypes} = require("wa-sticker-formatter");
// ============== ආතල් හුත්තෝ 🌝😂




/*

⠄⠄⠄⢰⣧⣼⣯⠄⣸⣠⣶⣶⣦⣾⠄⠄⠄⠄⡀⠄⢀⣿⣿⠄⠄⠄⢸⡇⠄⠄
⠄⠄⠄⣾⣿⠿⠿⠶⠿⢿⣿⣿⣿⣿⣦⣤⣄⢀⡅⢠⣾⣛⡉⠄⠄⠄⠸⢀⣿⠄
⠄⠄⢀⡋⣡⣴⣶⣶⡀⠄⠄⠙⢿⣿⣿⣿⣿⣿⣴⣿⣿⣿⢃⣤⣄⣀⣥⣿⣿⠄
⠄⠄⢸⣇⠻⣿⣿⣿⣧⣀⢀⣠⡌⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠿⠿⣿⣿⣿⠄
⠄⢀⢸⣿⣷⣤⣤⣤⣬⣙⣛⢿⣿⣿⣿⣿⣿⣿⡿⣿⣿⡍⠄⠄⢀⣤⣄⠉⠋⣰
⠄⣼⣖⣿⣿⣿⣿⣿⣿⣿⣿⣿⢿⣿⣿⣿⣿⣿⢇⣿⣿⡷⠶⠶⢿⣿⣿⠇⢀⣤
⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣽⣿⣿⣿⡇⣿⣿⣿⣿⣿⣿⣷⣶⣥⣴⣿⡗
⢀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠄
⢸⣿⣦⣌⣛⣻⣿⣿⣧⠙⠛⠛⡭⠅⠒⠦⠭⣭⡻⣿⣿⣿⣿⣿⣿⣿⣿⡿⠃⠄
⠘⣿⣿⣿⣿⣿⣿⣿⣿⡆⠄⠄⠄⠄⠄⠄⠄⠄⠹⠈⢋⣽⣿⣿⣿⣿⣵⣾⠃⠄
⠄⠘⣿⣿⣿⣿⣿⣿⣿⣿⠄⣴⣿⣶⣄⠄⣴⣶⠄⢀⣾⣿⣿⣿⣿⣿⣿⠃⠄⠄
⠄⠄⠈⠻⣿⣿⣿⣿⣿⣿⡄⢻⣿⣿⣿⠄⣿⣿⡀⣾⣿⣿⣿⣿⣛⠛⠁⠄⠄⠄
⠄⠄⠄⠄⠈⠛⢿⣿⣿⣿⠁⠞⢿⣿⣿⡄⢿⣿⡇⣸⣿⣿⠿⠛⠁⠄⠄⠄⠄⠄
⠄⠄⠄⠄⠄⠄⠄⠉⠻⣿⣿⣾⣦⡙⠻⣷⣾⣿⠃⠿⠋⠁⠄⠄⠄⠄⠄⢀⣠⣴
⣿⣿⣿⣶⣶⣮⣥⣒⠲⢮⣝⡿⣿⣿⡆⣿⡿⠃⠄⠄⠄⠄⠄⠄⠄⣠⣴⣿⣿⣿

̶ ̶ ̶͟͞ ̶͟͞ ̶͟͞ ̶🍃:𝗜 𝗙𝗨𝗖𝗞𝝣𝗗 𝗬𝝧𝗨𝗥 𝗗𝝣𝗩𝗜𝗖𝝣:|🍃 ͟͞


*/

//  ===================  Didula MD Fuck Imdex ==============



cmd({
    on: "body"
}, async (conn, mek, m, { from, body, isGroup, isAdmins, isBotAdmins, reply, sender }) => {
    try {
        // Auto Bio Update
        if (config.AUTO_BIO === 'true') {
            const bioText = `𝐃𝐢𝐝𝐮𝐥𝐚 𝐌𝐃 𝐕𝟐 𝐑𝐮𝐧𝐧𝐢𝐧𝐠 𝐒𝐦𝐨𝐨𝐭𝐡𝐥𝐲...`;
            await conn.updateProfileStatus(bioText);
        }

        // Auto Typing Status
        if (config.AUTO_TYPING === 'true') {
            await conn.sendPresenceUpdate('composing', mek.key.remoteJid);
        }

        // Recording Status
        if (config.RECORDING === 'true') {
            await conn.sendPresenceUpdate('recording', mek.key.remoteJid);
        }

        // Online Status
        if (config.ALWAYS_ONLINE === 'true') {
            await conn.sendPresenceUpdate('available', mek.key.remoteJid);
        } else {
            await conn.sendPresenceUpdate('unavailable', mek.key.remoteJid);
        }

    } catch (error) {
        console.error("Error processing message:", error);
        reply("An error occurred while processing your message. Please try again later.");
    }
});











//   ================== convert category plugin====================
const googleTTS = require('google-tts-api')

cmd({
    pattern: "tts",
    desc: "Text-to-speech",
    category: "convert",
    filename: __filename
},
async(conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {


if(!q) return reply("*_Please give me a text._*")

const url = googleTTS.getAudioUrl(q, {
  lang: 'en',
  slow: false,
  host: 'https://translate.google.com',
});

await conn.sendMessage(from,{audio: {url: url },mimetype:"audio/mpeg"},{quoted:mek})
        
}catch(e){
console.log(e)
reply(`${e}`)

}
})



cmd({
    pattern: "readmore",
    desc: "Readmore message",
    category: "convert",
    react: "📝",
    filename: __filename
}, async (conn, mek, m, {
    from, quoted, body, isCmd, command, args, q, isGroup, sender
}) => {
    try {
        // Get the message text after the command (.readmore text)
        let readmoreText = q ? q : "No text provided";

        // Create the "Readmore" effect by adding a special character to split the text
        let readmore = "\u200B".repeat(4000); // This creates a large gap between text

        // Full message to send
        let replyText = `Didula MD V2\n\n${readmore}${readmoreText}`;

        // Send the message with the "Readmore" functionality
        await conn.sendMessage(from, { text: replyText }, { quoted: mek });

        // React to the message
        await conn.sendMessage(from, { react: { text: "", key: mek.key } });

    } catch (e) {
        console.log(e);
        reply(`Error: ${e.message}`);
    }
});




cmd({
    pattern: "convert",
    desc: "Convert an amount from one currency to another.",
    category: "convert",
    react: "💱",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        if (args.length < 3) {
            return reply("Usage: .convert <amount> <from_currency> <to_currency>");
        }

        const amount = args[0];
        const fromCurrency = args[1].toUpperCase();
        const toCurrency = args[2].toUpperCase();

        if (isNaN(amount)) {
            return reply("Please provide a valid amount.");
        }

        const apiUrl = `https://api.exchangerate-api.com/v4/latest/${fromCurrency}`;
        const response = await axios.get(apiUrl);
        const data = response.data;

        if (!data.rates[toCurrency]) {
            return reply(`Conversion rate for ${toCurrency} not found.`);
        }

        const convertedAmount = (amount * data.rates[toCurrency]).toFixed(2);
        let conversionInfo = `💸_*Currency Conversion*_💸\n\n`;
        conversionInfo += `💵 *Amount*: ${amount} ${fromCurrency}\n`;
        conversionInfo += `🔄 *Converted Amount*: ${convertedAmount} ${toCurrency}\n`;
        conversionInfo += `📈 *Exchange Rate*: 1 ${fromCurrency} = ${data.rates[toCurrency]} ${toCurrency}\n
        
> 🔱 𝐏𝐫𝐨𝐣𝐞𝐜𝐭𝐬 𝐎𝐟 𝐃𝐢𝐝𝐮𝐥𝐚 𝐑𝐚𝐬𝐡𝐦𝐢𝐤𝐚 💀🙌
        `;

        await conn.sendMessage(from, { text: conversionInfo }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply(`Error fetching data: ${e.message}`);
    }
});








const { image2url } = require('@dark-yasiya/imgbb.js')

cmd({
    pattern: "img2url",
    desc: "Image convert to url",
    category: "convert",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{




    const isQuotedImage = m.quoted ? ((m.quoted.type === 'imageMessage') || (isQuotedViewOnce ? (m.quoted.msg.type === 'imageMessage') : false)) : false

     if ((m.type === 'imageMessage') || isQuotedImage) {
      var nameJpg = `didulamd`
      isQuotedImage ? await m.quoted.download(nameJpg) : await m.download(nameJpg)

let data = await image2url(nameJpg + '.jpg');

let msg = `*Url :* ${data.result.url}

> 🔱 𝐏𝐫𝐨𝐣𝐞𝐜𝐭𝐬 𝐎𝐟 𝐃𝐢𝐝𝐮𝐥𝐚 𝐑𝐚𝐬𝐡𝐦𝐢𝐤𝐚 💀🙌`

reply(`${msg}`)
     } else {
reply("*_Please reply an image._*")
     }
}catch(e){
console.log(e)
reply(`${e}`)
}
})









var imgmsg =''
if(config.LANG === 'SI') imgmsg = '*ස්ටිකරයකට mention දෙන්න !*'
else imgmsg = "*Reply to a sticker !*"
var descg = ''
if(config.LANG === 'SI') descg = "එය ඔබගේ mention දුන් sticker img බවට පරිවර්තනය කරයි."
else descg = "It converts your replied sticker to img."

cmd({
    pattern: "toimg",
    react: "🔮",
    alias: ["s","stic"],
    desc: descg,
    category: "convert",
    use: '.sticker <Reply to image>',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
    const isQuotedViewOnce = m.quoted ? (m.quoted.type === 'viewOnceMessage') : false
    const isQuotedImage = m.quoted ? ((m.quoted.type === 'imageMessage') || (isQuotedViewOnce ? (m.quoted.msg.type === 'imageMessage') : false)) : false
    const isQuotedVideo = m.quoted ? ((m.quoted.type === 'videoMessage') || (isQuotedViewOnce ? (m.quoted.msg.type === 'videoMessage') : false)) : false
    const isQuotedSticker = m.quoted ? (m.quoted.type === 'stickerMessage') : false
if ( isQuotedSticker ) { 

var nameJpg = getRandom('');
let buff = isQuotedSticker ? await m.quoted.download(nameJpg) : await m.download(nameJpg)
let type = await fileType.fromBuffer(buff);
await fs.promises.writeFile("./" + type.ext, buff);  
await conn.sendMessage(from, { image: fs.readFileSync("./" + type.ext), caption: config.FOOTER }, { quoted: mek })

}else return await  reply(imgmsg)
} catch (e) {
reply('*Error !!*')
l(e)
}
})



cmd({
    pattern: "sticker",
    react: "🔮",
    alias: ["s","stic"],

    category: "convert",
    use: '.sticker <Reply to image>',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
    const isQuotedViewOnce = m.quoted ? (m.quoted.type === 'viewOnceMessage') : false
    const isQuotedImage = m.quoted ? ((m.quoted.type === 'imageMessage') || (isQuotedViewOnce ? (m.quoted.msg.type === 'imageMessage') : false)) : false
    const isQuotedVideo = m.quoted ? ((m.quoted.type === 'videoMessage') || (isQuotedViewOnce ? (m.quoted.msg.type === 'videoMessage') : false)) : false
    const isQuotedSticker = m.quoted ? (m.quoted.type === 'stickerMessage') : false
     if ((m.type === 'imageMessage') || isQuotedImage) {
      var nameJpg = getRandom('')
      isQuotedImage ? await m.quoted.download(nameJpg) : await m.download(nameJpg)
    let sticker = new Sticker(nameJpg + '.jpg', {
    pack: 'Didula Md', // The pack name
    author: 'Didula Rashmika', // The author name
      type: q.includes("--crop" || '-c') ? StickerTypes.CROPPED : StickerTypes.FULL,
      categories: ["🤩", "🎉"], // The sticker category
      id: "12345", // The sticker id
      quality: 75, // The quality of the output file
      background: "transparent", // The sticker background color (only for full stickers)
  });
  const buffer = await sticker.toBuffer();
  return conn.sendMessage(from, {sticker: buffer}, {quoted: mek })
}  else if ( isQuotedSticker ) { 

    var nameWebp = getRandom('')
    await m.quoted.download(nameWebp)
  let sticker = new Sticker(nameWebp + '.webp', {
    pack: 'Didula Md', // The pack name
    author: 'Didula Rashmika', // The author name
    type: q.includes("--crop" || '-c') ? StickerTypes.CROPPED : StickerTypes.FULL,
    categories: ["🤩", "🎉"], // The sticker category
    id: "12345", // The sticker id
    quality: 75, // The quality of the output file
    background: "transparent", // The sticker background color (only for full stickers)
});
const buffer = await sticker.toBuffer();
return conn.sendMessage(from, {sticker: buffer}, {quoted: mek })
}else return await  reply(imgmsg)
} catch (e) {
    reply('Error !!')
    console.log(e)
}
})









// Logo List Command
cmd({
    pattern: "logolist",
    desc: "Create logos",
    category: "convert",
    filename: __filename
},
async(conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        if(!q) return reply("*_Please give me a text._*")

        let logoMsg = `*_Didula MD V2 💚 LOGO MAKER_*

───────────────────
*Text :* ${q}
───────────────────

_🔢 Reply Below Number :_

 1 || Black Pink
 2 || Black Pink 2
 3 || Black Pink 3
 4 || Naruto
 5 || Digital Glitch
 6 || Pixel Glitch
 7 || Comic Style
 8 || Neon Light
 9 || Free Bear
10 || Devil Wings
11 || Futuristic Technology
12 || Silver 3D
13 || 3D Paper Cut
14 || Pubg 1
15 || Pubg 2
16 || Free Fire Cover
17 || Text On Wet Glass
18 || Typography
19 || Modern Gold
20 || Matrix

> ᴩʀᴏᴊᴇᴄᴛꜱ ᴏꜰ ᴅɪᴅᴜʟᴀ ʀᴀꜱʜᴍɪᴋᴀ`

        const fdChannel = {
            newsletterJid: "@newsletter",
            newsletterName: "Didula MD V2 💚",
            serverMessageId: 999
        };
        const contextMsg = {
            mentionedJid: [m.sender],
            forwardingScore: 999,
            isForwarded: true,
            forwardedNewsletterMessageInfo: fdChannel
        };
        const msgBody = {
            image: {url:`https://i.ibb.co/tC37Q7B/20241220-122443.jpg`},
            caption: logoMsg,
            contextInfo: contextMsg
        };
        let send = await conn.sendMessage(from, msgBody, {
            'quoted': mek
        })

        conn.ev.on('messages.upsert', async (msgUpdate) => {
            const msg = msgUpdate.messages[0];
            if (!msg.message || !msg.message.extendedTextMessage) return;

            const selectedOption = msg.message.extendedTextMessage.text.trim();

            if (msg.message.extendedTextMessage.contextInfo && msg.message.extendedTextMessage.contextInfo.stanzaId === send.key.id) {
                switch (selectedOption) {
                    case '1':
                        let data1 = await fetchJson(`${apilink2}/api/logo?url=${logo1}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data1.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '2':
                        let data2 = await fetchJson(`${apilink2}/api/logo?url=${logo2}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data2.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '3':
                        let data3 = await fetchJson(`${apilink2}/api/logo?url=${logo3}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data3.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '4':
                        let data4 = await fetchJson(`${apilink2}/api/logo?url=${logo4}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data4.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '5':
                        let data5 = await fetchJson(`${apilink2}/api/logo?url=${logo5}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data5.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '6':
                        let data6 = await fetchJson(`${apilink2}/api/logo?url=${logo6}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data6.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '7':
                        let data7 = await fetchJson(`${apilink2}/api/logo?url=${logo7}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data7.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '8':
                        let data8 = await fetchJson(`${apilink2}/api/logo?url=${logo8}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data8.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '9':
                        let data9 = await fetchJson(`${apilink2}/api/logo?url=${logo9}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data9.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '10':
                        let data10 = await fetchJson(`${apilink2}/api/logo?url=${logo10}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data10.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '11':
                        let data11 = await fetchJson(`${apilink2}/api/logo?url=${logo11}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data11.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '12':
                        let data12 = await fetchJson(`${apilink2}/api/logo?url=${logo12}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data12.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '13':
                        let data13 = await fetchJson(`${apilink2}/api/logo?url=${logo13}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data13.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '14':
                        let data14 = await fetchJson(`${apilink2}/api/logo?url=${logo14}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data14.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '15':
                        let data15 = await fetchJson(`${apilink2}/api/logo?url=${logo15}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data15.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '16':
                        let data16 = await fetchJson(`${apilink2}/api/logo?url=${logo16}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data16.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '17':
                        let data17 = await fetchJson(`${apilink2}/api/logo?url=${logo17}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data17.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '18':
                        let data18 = await fetchJson(`${apilink2}/api/logo?url=${logo18}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data18.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '19':
                        let data19 = await fetchJson(`${apilink2}/api/logo?url=${logo19}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data19.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    case '20':
                        let data20 = await fetchJson(`${apilink2}/api/logo?url=${logo20}&name=${q}`)
                        await conn.sendMessage(from, { image :{url : `${data20.result.download_url}`}, caption : `${caption}`},{quoted : mek})
                        break;
                    default:
                        reply("*_Invalid number.Please reply a valid number._*");
                }
            }
        })

    }catch(e){
        console.log(e)
        reply(`${e}`)
    }
});

// Constants for logo URLs
const logo1 = 'https://en.ephoto360.com/create-a-blackpink-style-logo-with-members-signatures-810.html';
const logo2 = `https://en.ephoto360.com/online-blackpink-style-logo-maker-effect-711.html`;
const logo3 = `https://en.ephoto360.com/create-a-blackpink-neon-logo-text-effect-online-710.html`;
const logo4 = `https://en.ephoto360.com/naruto-shippuden-logo-style-text-effect-online-808.html`;
const logo5 = `https://en.ephoto360.com/create-digital-glitch-text-effects-online-767.html`;
const logo6 = `https://en.ephoto360.com/create-pixel-glitch-text-effect-online-769.html`;
const logo7 = `https://en.ephoto360.com/create-online-3d-comic-style-text-effects-817.html`;
const logo8 = `https://en.ephoto360.com/create-colorful-neon-light-text-effects-online-797.html`;
const logo9 = `https://en.ephoto360.com/free-bear-logo-maker-online-673.html`;
const logo10 = `https://en.ephoto360.com/neon-devil-wings-text-effect-online-683.html`;
const logo11 = `https://en.ephoto360.com/light-text-effect-futuristic-technology-style-648.html`;
const logo12 = `https://en.ephoto360.com/create-glossy-silver-3d-text-effect-online-802.html`;
const logo13 = `https://en.ephoto360.com/multicolor-3d-paper-cut-style-text-effect-658.html`;
const logo14 = `https://en.ephoto360.com/free-pubg-logo-maker-online-609.html`;
const logo15 = `https://en.ephoto360.com/pubg-logo-maker-cute-character-online-617.html`;
const logo16 = `https://en.ephoto360.com/create-free-fire-facebook-cover-online-567.html`;
const logo17 = `https://en.ephoto360.com/write-text-on-wet-glass-online-589.html`;
const logo18 = `https://en.ephoto360.com/create-online-typography-art-effects-with-multiple-layers-811.html`;
const logo19 = `https://en.ephoto360.com/modern-gold-5-215.html`;
const logo20 = `https://en.ephoto360.com/matrix-text-effect-154.html`;

const apilink2 = 'https://api-pink-venom.vercel.app';
const caption = `> ᴩʀᴏᴊᴇᴄᴛꜱ ᴏꜰ ᴅɪᴅᴜʟᴀ ʀᴀꜱʜᴍɪᴋᴀ`;






//   ================== group category plugin====================



// Helper function to check permissions
const checkPermissions = (isGroup, isAdmins, isOwner, isBotAdmins) => {
    if (!isGroup) return 'This command can only be used in groups.';
    if (!isAdmins && !isOwner) return 'This command can only be used by group admins.';
    if (!isBotAdmins) return 'Bot must be admin to use this command.';
    return null;
};


cmd({
pattern: "del",
react: "❌",
alias: ["del"],
desc: "delete message",
category: "group",
use: '.del',
filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants,  isItzcp, groupAdmins, isBotAdmins, isAdmins, reply}) => {
if (!isOwner ||  !isAdmins) return;
try{
if (!m.quoted) return reply(mg.notextfordel);
const key = {
            remoteJid: m.chat,
            fromMe: false,
            id: m.quoted.id,
            participant: m.quoted.sender
        }
        await conn.sendMessage(m.chat, { delete: key })
} catch(e) {
console.log(e);
reply('successful..👨‍💻✅')
} 
})






cmd({
    pattern: "join",
    fromMe: true,  // Only bot owner can use this command
    desc: "Make the bot join a group using an invite link.",
    category: "group",
    react: "🌀",
    filename: __filename
}, async (conn, mek, m, { from, quoted, body, args, q, reply }) => {
    try {
        // Check if invite link is provided
        if (!q || !q.includes("chat.whatsapp.com")) {
            return await reply("Please provide a valid WhatsApp group invite link.");
        }
        // Extract the group code from the invite link
        const inviteCode = q.split("chat.whatsapp.com/")[1];
        // Make the bot join the group using the invite code
        const response = await conn.groupAcceptInvite(inviteCode);
        // Send confirmation message if successfully joined
        if (response) {
            await reply("✅ Successfully joined the group!");
        } else {
            await reply("❌ Failed to join the group. Please check the invite link.");
        }
    } catch (e) {
        console.error("Error while joining group:", e);
        await reply("❗ An error occurred while trying to join the group.");
    }
});
//============================================================================================================================
// Leave Command
cmd({
    pattern: "left",
    fromMe: true,  // Only bot owner can use this command
    desc: "Make the bot leave the group.",
    category: "group",
    react: "👋",
    filename: __filename
}, async (conn, mek, m, { from, isGroup, reply }) => {
    try {
        // Check if the command is used in a group
        if (!isGroup) {
            return await reply("❌ This command can only be used in a group.");
        }
        // Make the bot leave the group
        await conn.groupLeave(from);
        // Send confirmation message after leaving the group
        console.log(`Bot left the group: ${from}`);
    } catch (e) {
        console.error("Error while leaving group:", e);
        await reply("❗ An error occurred while trying to leave the group.");
    }
});
//============================================================================================================================
// Hidetag Command
cmd({
    pattern: "hidetag",
    fromMe: true,  // Only bot owner can use this command
    desc: "Send a message with hidden tags to all group members.",
    category: "group",
    react: "🔍",
    filename: __filename
}, async (conn, mek, m, { from, isGroup, args, q, participants, reply }) => {
    try {
        // Check if the command is used in a group
        if (!isGroup) {
            return await reply("❌ This command can only be used in a group.");
        }
        // Check if a message is provided
        if (!q) {
            return await reply("❗ Please provide a message to send.");
        }
        // Extract group participants' contact IDs
        const participantIds = participants.map((participant) => participant.id);
        // Send the message with hidden tags
        await conn.sendMessage(from, { 
            text: q, 
            mentions: participantIds 
        });
        console.log("Hidetag message sent to all group members.");
    } catch (e) {
        console.error("Error while sending hidetag message:", e);
        await reply("❗ An error occurred while trying to send the hidetag message.");
    }
});





// Mute Group Command
cmd({
    pattern: "mute",
    react: "🔇",
    desc: "close a group",
    category: "group",
    use: '.mute',
    filename: __filename
},
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{                   
if (!isGroup) return reply(ONLGROUP)
if (!isBotAdmins) return reply(botAdmin)
if (!isAdmins) return reply(ADMIN)

        await conn.groupSettingUpdate(mek.chat, 'announcement')
        const sendmsg = await conn.sendMessage(mek.chat.G_MUTE)
await conn.sendMessage(from, { react: { text: `✅`, key: mek.key }}) 
} catch (e) {
reply('🛑 GROUP IS CLOSED MY BOT OWNER')
l(e)
}
})

// Unmute Group Command
cmd({
    pattern: "unmute",
    react: "🔊",
    desc: "open a group",
    category: "group",
    use: '.unmute',
    filename: __filename
},
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{                   
if (!isGroup) return reply(ONLGROUP)
if (!isBotAdmins) return reply(botAdmin)
if (!isAdmins) return reply(ADMIN)

        await conn.groupSettingUpdate(mek.chat, 'not_announcement')
        const sendmsg = await conn.sendMessage(mek.chat.G_UNMUTE)
await conn.sendMessage(from, { react: { text: `✅`, key: mek.key }}) 
} catch (e) {
reply('🛑 GROUP IS OPEN MY BOT OWNER')
l(e)
}
})

// Promote Command
cmd({
    pattern: "promote",
    react: "📍",
    desc: "promote admin to a member",
    category: "group",
    use: '.promote',
    filename: __filename
},
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{                   
if (!isGroup) return reply(ONLGROUP)
if (!isBotAdmins) return reply(botAdmin)
if (!isAdmins) return reply(ADMIN)

         let users = mek.mentionedJid ? mek.mentionedJid : mek.quoted ? mek.quoted.sender : q.replace(/[^0-9]/g, '')+'@s.whatsapp.net'
                await conn.groupParticipantsUpdate(mek.chat, [users], 'promote').then((res) => reply(jsonformat(res))).catch((err) => reply(jsonformat(err)))
        reply('🛑 GROUP ADMIN PROMOTE BY MY BOT OWNER')
await conn.sendMessage(from, { react: { text: `✅`, key: mek.key }}) 
} catch (e) {
reply('*Done ✓✓*')
l(e)
}
})

// Demote Command
cmd({
    pattern: "demote",
    react: "📍",
    desc: "demote admin to a member",
    category: "group",
    use: '.demote',
    filename: __filename
},
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{                   
if (!isGroup) return reply(ONLGROUP)
if (!isBotAdmins) return reply(botAdmin)
if (!isAdmins) return reply(ADMIN)

                 let users = mek.mentionedJid ? mek.mentionedJid : mek.quoted ? mek.quoted.sender : q.replace(/[^0-9]/g, '')+'@s.whatsapp.net'
                await conn.groupParticipantsUpdate(mek.chat, [users], 'demote').then((res) => reply(jsonformat(res))).catch((err) => reply(jsonformat(err)))
reply('🛑 GROUP ADMIN DEMOTE BY MY BOT OWNER')
await conn.sendMessage(from, { react: { text: `✅`, key: mek.key }}) 
} catch (e) {
reply('*Done ✓✓*')
l(e)
}
})

// Remove Member Command
cmd({
    pattern: "remove",
    desc: "Remove a member from the group.",
    category: "group",
    react: "🚫",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        if (!isGroup) return reply('This command can only be used in a group.')
        if (!isBotAdmins) return reply('Bot must be an admin to use this command.')
        if (!isAdmins) return reply('You must be an admin to use this command.')

        const user = m.mentioned[0] || m.quoted?.sender
        if (!user) return reply('Please tag or reply to a user to remove.')

        await conn.groupParticipantsUpdate(from, [user], 'remove')
        await reply(`@${user.split('@')[0]} has been removed from the group.`, { mentions: [user] })
    } catch (e) {
        console.log(e)
        reply(`${e}`)
    }
})

// Add Member Command
cmd({
    pattern: "add",
    desc: "Add a member to the group.",
    category: "group",
    react: "✅",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        if (!isGroup) return reply('This command can only be used in a group.')
        if (!isBotAdmins) return reply('Bot must be an admin to use this command.')
        if (!isAdmins) return reply('You must be an admin to use this command.')

        const user = q.split(' ')[0]
        if (!user) return reply('Please provide a phone number to add.')

        await conn.groupParticipantsUpdate(from, [`${user}@s.whatsapp.net`], 'add')
        await reply(`@${user} has been added to the group.`, { mentions: [`${user}@s.whatsapp.net`] })
    } catch (e) {
        console.log(e)
        reply(`${e}`)
    }
})

// Group Info Command
cmd({
    pattern: "groupinfo",
    desc: "Get information about the group.",
    category: "group",
    filename: __filename,
    react: "ℹ️"
},
async(conn, mek, m, { from, isGroup, groupMetadata, groupName, participants, groupAdmins, reply }) => {
    try {
        if (!isGroup) return reply('This command can only be used in groups.');

        const groupInfo = `*Didula MD V2 💚*\n\n
📋 *Group Information*
👥 *Name:* ${groupName}
📝 *Description:* ${groupMetadata.desc || 'No description'}
🆔 *ID:* ${from}
👑 *Owner:* ${groupMetadata.owner || 'Not available'}
👤 *Members:* ${participants.length}
👮 *Admins:* ${groupAdmins.length}
📅 *Created:* ${new Date(groupMetadata.creation * 1000).toLocaleString()}\n\n*Didula MD V2 💚*
        `;
        reply(groupInfo);
    } catch(e) {
        console.error(e);
        reply(`❌ Error: ${e}`);
    }
})

// Tag Admins Command
cmd({
    pattern: "tagadmin",
    alais:["tagadmins"],
    react: "🙀",
    desc: "Tags all the admins in the group.",
    category: "group",
    filename: __filename,
},           
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
        if (!isGroup) return reply(`This command is only for groups.`);
        if (!isAdmins) return reply(`This command is only for group admin.`);

        const admins = groupAdmins;
        if (admins.length === 0) {
            return reply('There are no admins in this group.');
        }
        let adminTagMessage = '*TAGGING ALL ADMINS IN THE GROUP 🔳:*\n\n';
        for (let admin of admins) {
            adminTagMessage += `@${admin.split('@')[0]}\n`;
        }
        await conn.sendMessage(from, { text: adminTagMessage, mentions: admins }, { quoted: mek });
    } catch (e) {
        console.error('Error tagging admins:', e);
        reply('you are not an admin.');
    }
})

// Open Time Command
cmd({
    pattern: "opentime",
    react: "🔖",
    desc: "To open group to a time",
    category: "group",
    use: '.opentime',
    filename: __filename
},
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{   
if (!isGroup) return reply(ONLGROUP)
if (!isAdmins) return reply(ADMIN)        
  if (args[1] == 'second') {
                    var timer = args[0] * `1000`
                } else if (args[1] == 'minute') {
                    var timer = args[0] * `60000`
                } else if (args[1] == 'hour') {
                    var timer = args[0] * `3600000`
                } else if (args[1] == 'day') {
                    var timer = args[0] * `86400000`
                } else {
                    return reply('*select:*\nsecond\nminute\nhour\n\n*example*\n10 second')
                }
                reply(`Open time ${q} starting from now`)
                setTimeout(() => {
                    var nomor = mek.participant
                    const open = `*OPEN TIME* THE GROUP WAS OPENED BY AWAIS MD TO APPROVED ADMIN\n NOW MEMBERS CAN SEND MESSAGES 🔓`
                    conn.groupSettingUpdate(from, 'not_announcement')
                    reply(open)
                }, timer)
await conn.sendMessage(from, { react: { text: `✅`, key: mek.key }}) 
} catch (e) {
reply('*Error !!*')
l(e)
}
})

// Close Time Command
cmd({
    pattern: "closetime",
    react: "🔖",
    desc: "To close group to a time",
    category: "group",
    use: '.closstime',
    filename: __filename
},
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{   
if (!isGroup) return reply(ONLGROUP)
if (!isAdmins) return reply(ADMIN)        
                if (args[1] == 'second') {
                    var timer = args[0] * `1000`
                } else if (args[1] == 'minute') {
                    var timer = args[0] * `60000`
                } else if (args[1] == 'hour') {
                    var timer = args[0] * `3600000`
                } else if (args[1] == 'day') {
                    var timer = args[0] * `86400000`
                } else {
                    return reply('*select:*\nsecond\nminute\nhour\n\n*Example*\n10 second')
                }
                reply(`Close time ${q} starting from now`)
                setTimeout(() => {
                    var nomor = m.participant
                    const close = `*CLOSE TIME* GROUP CLOSED BY AWAIS MD AT APPROVED ADMIN\nNOW ONLY ADMIN CAN SEND MESSAGES 🔐`
                    conn.groupSettingUpdate(from, 'announcement')
                    reply(close)
                }, timer)
await conn.sendMessage(from, { react: { text: `✅`, key: mek.key }}) 
} catch (e) {
reply('*Error !!*')
l(e)
}
})

// Kick All Command
cmd({
    pattern: "kickall",
    desc: "Kicks all non-admin members from the group.",
    react: "👏",
    category: "group",
    filename: __filename,
},           
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
      if (!isAdmins) return reply(`ɪ ɴᴇᴇᴅ ᴀᴅᴍɪɴ 💀`)
      if (!isOwner) return reply(`ʏᴏᴜ ᴀʀᴇ ɴᴏᴛ ᴏᴡɴᴇʀ ᴏꜰ ᴅɪᴅᴜʟᴀ ᴍᴅ`)

        if (!isGroup) return reply(`This command is only for groups.`);
        if (!isBotAdmins) return reply(`I need admin privileges to kick users.`);
        
        const allParticipants = groupMetadata.participants;
        const nonAdminParticipants = allParticipants.filter(member => !groupAdmins.includes(member.id));
        
        if (nonAdminParticipants.length === 0) {
            return reply('There are no non-admin members to kick.');
        }
        
        for (let participant of nonAdminParticipants) {
            await conn.groupParticipantsUpdate(m.chat, [participant.id], "remove");
        }
        
        reply(`Didula MD V2 💚 Successfully kicked all non-admin members from the group.`);

    } catch (e) {
        console.error('Error kicking users:', e);
        reply('An error occurred while trying to kick all members. Please try again.');
    }
})






//   ================== owner category plugin====================

cmd({
    pattern: "msginfo",
    desc: "Get msg info",
    category: "owner",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{


if(!isOwner) return reply('*_This is an owner cmd._*')

let number = m.quoted.sender.replace('@s.whatsapp.net', '')
    
let inf = `*DIDULA MD V2 MESSEGE INFO*

*➤ Message ID :* ${m.quoted.id}

*➤ Message Type :* ${m.quoted.type}

*➤ Sender Number :* ${number}

> 🔱 𝐏𝐫𝐨𝐣𝐞𝐜𝐭𝐬 𝐎𝐟 𝐃𝐢𝐝𝐮𝐥𝐚 𝐑𝐚𝐬𝐡𝐦𝐢𝐤𝐚 💀🙌`
const msg = {
            newsletterJid: "120363343196447945@newsletter",
            newsletterName: "Didula MD V2",
            serverMessageId: 999
          };
          const test1 = {
            mentionedJid: [m.sender],
            forwardingScore: 999,
            isForwarded: true,
            forwardedNewsletterMessageInfo: msg
          };
          const test2 = {
            text: inf,
            contextInfo: test1
          };
         await conn.sendMessage(from, test2, {
            'quoted': mek
          })
    
}catch(e){
reply(`${e}`)
}
})





cmd({
    pattern: "block",
    desc: "Block a user.",
    category: "owner",
    react: "🚫",
    filename: __filename
},
async (conn, mek, m, { from, isOwner, quoted, reply }) => {
    if (!isOwner) return reply("❌ owner command !");
    if (!quoted) return reply("❌ Please reply to the user you want to block.");

    const user = quoted.sender;
    try {
        await conn.updateBlockStatus(user, 'block');
        reply(`😑🖕 ${user} blocked successfully.`);
    } catch (error) {
        reply(`❌ Error blocking user: ${error.message}`);
    }
});

// Unblock User Command
cmd({
    pattern: "unblock",
    desc: "Unblock a user.",
    category: "owner",
    react: "✅",
    filename: __filename
},
async (conn, mek, m, { from, isOwner, quoted, reply }) => {
    if (!isOwner) return reply("❌ You are not the owner!");
    if (!quoted) return reply("❌ Please reply to the user you want to unblock.");

    const user = quoted.sender;
    try {
        await conn.updateBlockStatus(user, 'unblock');
        reply(`✅ User ${user} unblocked successfully.`);
    } catch (error) {
        reply(`❌ Error unblocking user: ${error.message}`);
    }
});

// Clear All Chats Command
cmd({
    pattern: "clearchats",
    desc: "Clear all chats from the bot.",
    category: "owner",
    react: "🧹",
    filename: __filename
},
async (conn, mek, m, { from, isOwner, reply }) => {
    if (!isOwner) return reply("❌ You are not the owner!");
    try {
        const chats = conn.chats.all();
        for (const chat of chats) {
            await conn.modifyChat(chat.jid, 'delete');
        }
        reply("🧹 All chats cleared successfully!");
    } catch (error) {
        reply(`❌ Error clearing chats: ${error.message}`);
    }
});

// Forward Message Command
cmd({
    pattern: "forward",
    desc: "Forward messages",
    alias: ['fo'],
    category: "owner",
    use: ".forward <Jid address>",
    filename: __filename
}, async (conn, mek, store, {
    from,
    quoted,
    q,
    isOwner,
    isMe,
    reply
}) => {
    if (!isOwner & !isMe) {
        return reply("*You Are Not Owner Or Bot*");
    }

    if (!q) {
        return reply("Please provide a target JID address ❌");
    }

    if (!quoted) {
        return reply("Please reply to a message you want to forward ❌");
    }

    const forwardMessage = quoted.fakeObj ? quoted.fakeObj : quoted;

    try {
        await conn.sendMessage(q, { forward: forwardMessage }, { quoted: mek });
        return reply(`*Message forwarded successfully to:*\n\n${q} ✅`);
    } catch (error) {
        console.error("Error forwarding message:", error);
        return reply("Failed to forward the message ❌");
    }
});

// Restart Bot Command
cmd({
    pattern: "restart",
    desc: "restart the bot",
    category: "owner",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
    const {exec} = require("child_process")
    reply("Didula MD V2 💚 restarting...")
    await sleep(1500)
    exec("pm2 restart all")
}catch(e){
    console.log(e)
    reply(`${e}`)
}
});

/*
// JID Command
cmd({
    pattern: "jid",
    react: "💻",
    alias: ["jids"],
    desc: "Check bot's ping",
    category: "owner",
    use: '.ping',
    filename: __filename
},
async(conn, mek, m, {from, mnu, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
    try{
        reply(from)
    } catch (e) {
        reply(`${e}`)
        console.log(e)
    }
});

*/


// Group JIDs List Command
cmd({
    pattern: "gjid",
    desc: "Get the list of JIDs for all groups the bot is part of.",
    category: "owner",
    react: "📝",
    filename: __filename
},
async (conn, mek, m, { from, isOwner, reply }) => {
    if (!isOwner) return reply("❌ You are not the owner!");
    const groups = await conn.groupFetchAllParticipating();
    const groupJids = Object.keys(groups).join('\n');
    reply(`📝 *Group JIDs:*\n\n${groupJids}`);
});









//   ================== search category plugin====================
cmd({
    pattern: "npm",
    desc: "Get npm info",
    category: "search",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{


let emptyMsg = `*use  .npm axios*`
if(!q) return reply(emptyMsg)
    
let response = await axios.get(`https://www.npmjs.com/package/${q}`)
let $ = cheerio.load(response.data)

const name = $('#top > div.w-100.ph0-l.ph3.ph4-m > h2 > span').text().trim()
const version = $('#top > div.w-100.ph0-l.ph3.ph4-m > span:nth-child(2)').text().trim()
const date = $('#top > div.w-100.ph0-l.ph3.ph4-m > span:nth-child(4) > time').text().trim()
const ghlink = $('#repository-link').text().trim()
const img = `https://static-production.npmjs.com/58a19602036db1daee0d7863c94673a4.png`
    
let msg = `*DIDULA MD NPM INFO_*

*➤ Package :* ${name}

*➤ Version :* ${version}

*➤ Published :* ${date}

*➤ Repository :* ${ghlink}

> 🔱 𝐏𝐫𝐨𝐣𝐞𝐜𝐭𝐬 𝐎𝐟 𝐃𝐢𝐝𝐮𝐥𝐚 𝐑𝐚𝐬𝐡𝐦𝐢𝐤𝐚 💀🙌`

const fdChannel = {
            newsletterJid: "120363343196447945@newsletter",
            newsletterName: "Didula MD V2",
            serverMessageId: 999
          };
          const contextMsg = {
            forwardingScore: 999,
            isForwarded: true,
            forwardedNewsletterMessageInfo: fdChannel
          };
          const msgBody = {
	    image: {url: img},
            caption: msg,
            contextInfo: contextMsg
          };
         await conn.sendMessage(from, msgBody, {
            'quoted': mek
          })

let errrMsg = `*_Cant't find your npm package._*`
	
}catch(e){
console.log(e)
reply(`${errrMsg}`)
}
})




cmd({
    pattern: "cineinfo",
    desc: "cinesubz.co info",
    category: "search",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{



if(!q) return reply("*_Please give me a movie name._*")

let response = await axios.get(`https://cinesubz.co/?s=${q}`);
let $ = cheerio.load(response.data);
let url = $('#contenedor > div.module > div.content.rigth.csearch > div > div:nth-child(2) > article > div.details > div.title > a').attr('href');
    if(!url) {
        let errr = $('#contenedor > div.module > div.content.rigth.csearch > div > div.no-result.animation-2 > h2 > span').text()
        return reply(`No results to show with *${errr}*`)
    }
let result = await axios.get(`${url}`);
$ = cheerio.load(result.data)

const title = $('#single > div.content.right > div.sheader > div.data > h1').text()
const date = $('#single > div.content.right > div.sheader > div.data > div.extra > span.date').text()
const country = $('#single > div.content.right > div.sheader > div.data > div.extra > span.country').text()
const time = $('#single > div.content.right > div.sheader > div.data > div.extra > span.runtime').text()
const rate = $('#repimdb > strong').text()
const director = $('#cast > div:nth-child(2) > div > div.data > div.name > a').text()
const img = $('#single > div.content.right > div.sheader > div.poster > img').attr('src')

let msg = `🍟 *${title}*

🧿 *Release Date :* ${date}

🌍 *Country :* ${country}

⏱ *Duration :* ${time}

⭐ *IMDB Rate :* ${rate}

🤵‍♂ *Director :* ${director}

🖇 *Link :* ${url}

> 🔱 𝐏𝐫𝐨𝐣𝐞𝐜𝐭𝐬 𝐎𝐟 𝐃𝐢𝐝𝐮𝐥𝐚 𝐑𝐚𝐬𝐡𝐦𝐢𝐤𝐚 💀🙌`

await conn.sendMessage(from, {image:{url: img},caption:msg},{quoted:mek})
    
}catch(e){
console.log(e)
reply(`${e}`)
}
})



cmd({
    pattern: "githubstalk",
    desc: "Fetch detailed GitHub user profile including profile picture.",
    category: "search",
    react: "🖥️",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const username = args[0];
        if (!username) {
            return reply("Please provide a GitHub username.");
        }

        const apiUrl = `https://api.github.com/users/${username}`;
        const response = await axios.get(apiUrl);
        const data = response.data;

        let userInfo = `     🔍_*DIDULA-MD-V2 GIT STALK*_🔎
        
👤 *Username*: ${data.name || data.login}
🔗 *Github Url*:(${data.html_url})
📝 *Bio*: ${data.bio || 'Not available'}
🏙️ *Location*: ${data.location || 'Unknown'}
📊 *Public Repos*: ${data.public_repos}
👥 *Followers*: ${data.followers} | Following: ${data.following}
📅 *Created At*: ${new Date(data.created_at).toDateString()}
🔭 *Public Gists*: ${data.public_gists}

> *ᴩʀᴏᴊᴇᴄᴛꜱ ᴏꜰ ᴅɪᴅᴜʟᴀ ʀᴀꜱʜᴍɪᴋᴀ*
`;

         // Sending the image with caption
          const sentMsg = await conn.sendMessage(from, {


          text: userInfo,
          contextInfo: {

          forwardingScore: 999,
          isForwarded: true,
          forwardedNewsletterMessageInfo: {
          newsletterName: '◆─〈 ✦𝐃𝐢𝐝𝐮𝐥𝐚 𝐌𝐃 𝐕𝟐✦ 〉─◆',
          newsletterJid: "",
          },
          externalAdReply: {
              title: `Didula-MD-V2 Github Information`,
              body: `Can't Find The Information. You Can Try Another Way. Error Code 4043`,
              thumbnailUrl: data.avatar_url,
              sourceUrl: ``,
              mediaType: 1,
              renderLargerThumbnail: true
              }
                  }
              }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply(`єяяσя ƒєт¢нιηg ∂αтα: ${e.response ? e.response.data.message : e.message}`);
    }
});





cmd({
    pattern: "ipinfo",
    desc: "Get information about an IP address",
    use: ".ipinfo <IP_address>",
    category: "search",
    filename: __filename
}, async (conn, mek, m, { from, reply, q }) => {
    try {
        if (!q) return reply("⛔ Please provide an IP address!");

        const apiUrl = `https://BJ-Devs.serv00.net/Ip-Info.php?ip=${q}`;

        const response = await axios.get(apiUrl);
        const data = response.data;

        // Format the response message
        let resultMessage = `🔍 *IP Information:*\n\n`;
        resultMessage += `🌐 IP: ${data.ip}\n`;
        resultMessage += `🌍 Continent: ${data.continent_name} (${data.continent_code})\n`;
        resultMessage += `🇨🇳 Country: ${data.country_name} (${data.country_code2})\n`;
        resultMessage += `🏙️ City: ${data.city}\n`;
        resultMessage += `📍 State/Province: ${data.state_prov}\n`;
        resultMessage += `📮 Zip Code: ${data.zipcode}\n`;
        resultMessage += `📏 Latitude: ${data.latitude}\n`;
        resultMessage += `📏 Longitude: ${data.longitude}\n`;
        resultMessage += `📞 Calling Code: ${data.calling_code}\n`;
        resultMessage += `🕒 Time Zone: ${data.time_zone.name}\n`;
        resultMessage += `💻 ISP: ${data.isp}\n`;
        resultMessage += `🏳️ Country Flag: ${data.country_flag}\n`;

        // Send the response back
        reply(resultMessage);
    } catch (error) {
        console.error(error);
        if (error.response && error.response.data) {
            reply(`Error: ${error.response.data.message}`);
        } else {
            reply('An error occurred while fetching IP information. Please try again later.');
        }
    }
});







cmd({
    pattern: "yts",
    desc: "Search YouTube videos",
    use: ".yts <query>",
    category: "search",
    filename: __filename
}, async (conn, mek, m, { from, q, reply }) => {
    try {
        if (!q) return reply('⛔ Please provide a search query!');
        
        const searchResults = await yts(q);
        const videos = searchResults.videos.slice(0, 5); // Get the top 5 results
        
        if (videos.length === 0) {
            return reply('No results found.');
        }
        
        let resultMessage = '🎥 *YouTube Search Results:*\n\n';
        videos.forEach((video, index) => {
            resultMessage += `${index + 1}. [${video.title}](${video.url}) - ${video.author.name}\n`;
        });
        
        reply(resultMessage);
    } catch (e) {
        console.error(e);
        reply(`Error: ${e.message}`);
    }
});






// Image Search Command
cmd({
    pattern: "img",
    alias: ["googleimg"],
    react: "🔍",
    desc: "Search for images on Google",
    category: "search",
    use: '.imgsearch <query>',
    filename: __filename
},
async(conn, mek, m, { from, reply, q }) => {
    try {
        if (!q) return await reply("Please provide a search query!");

        g_i_s(q, (error, result) => {
            if (error || !result.length) return reply("No images found!");

            // Send the first 5 images
            const imageUrls = result.slice(0, 5).map(img => img.url);
            imageUrls.forEach(async (url) => {
                await conn.sendMessage(from, { image: { url } }, { quoted: mek });
            });
        });

    } catch (error) {
        console.error(error);
        reply('An error occurred while processing your request. Please try again later.');
    }
});

// Web Search Function (if needed)
cmd({
    pattern: "search",
    alias: ["websearch"],
    react: "🌐",
    desc: "Search the web for information",
    category: "search",
    use: '.search <query>',
    filename: __filename
},
async(conn, mek, m, { from, reply, q }) => {
    try {
        if (!q) return await reply("Please provide a search query!");

        // Using the search_web function
        const searchResults = await search_web(q);
        await reply(searchResults);

    } catch (error) {
        console.error(error);
        reply('An error occurred while searching. Please try again later.');
    }
});


// Group JIDs Search

// Get Profile Picture Command
cmd({
    pattern: "getpic",
    desc: "Get the group profile picture.",
    category: "search",
    react: "🖼️",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        if (!isGroup) return reply('This command can only be used in a group.')

        const groupPic = await conn.getProfilePicture(from)
        await conn.sendMessage(from, { 
            image: { url: groupPic }, 
            caption: 'Group Profile Picture' 
        })
    } catch (e) {
        console.log(e)
        reply(`${e}`)
    }
});


cmd({
    pattern: "vv",
    alias: ['retrive', "viewonce"],
    desc: "Fetch and resend a ViewOnce message content (image/video/voice).",
    category: "misc",
    use: '<query>',
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const quotedMessage = m.msg.contextInfo.quotedMessage; // Get quoted message

        if (quotedMessage && quotedMessage.viewOnceMessageV2) {
            const quot = quotedMessage.viewOnceMessageV2;
            if (quot.message.imageMessage) {
                let cap = quot.message.imageMessage.caption;
                let anu = await conn.downloadAndSaveMediaMessage(quot.message.imageMessage);
                return conn.sendMessage(from, { image: { url: anu }, caption: cap }, { quoted: mek });
            }
            if (quot.message.videoMessage) {
                let cap = quot.message.videoMessage.caption;
                let anu = await conn.downloadAndSaveMediaMessage(quot.message.videoMessage);
                return conn.sendMessage(from, { video: { url: anu }, caption: cap }, { quoted: mek });
            }
            if (quot.message.audioMessage) {
                let anu = await conn.downloadAndSaveMediaMessage(quot.message.audioMessage);
                return conn.sendMessage(from, { audio: { url: anu } }, { quoted: mek });
            }
        }

        // If there is no quoted message or it's not a ViewOnce message
        if (!m.quoted) return reply("Please reply to a ViewOnce message.");
        if (m.quoted.mtype === "viewOnceMessage") {
            if (m.quoted.message.imageMessage) {
                let cap = m.quoted.message.imageMessage.caption;
                let anu = await conn.downloadAndSaveMediaMessage(m.quoted.message.imageMessage);
                return conn.sendMessage(from, { image: { url: anu }, caption: cap }, { quoted: mek });
            }
            else if (m.quoted.message.videoMessage) {
                let cap = m.quoted.message.videoMessage.caption;
                let anu = await conn.downloadAndSaveMediaMessage(m.quoted.message.videoMessage);
                return conn.sendMessage(from, { video: { url: anu }, caption: cap }, { quoted: mek });
            }
        } else if (m.quoted.message.audioMessage) {
            let anu = await conn.downloadAndSaveMediaMessage(m.quoted.message.audioMessage);
            return conn.sendMessage(from, { audio: { url: anu } }, { quoted: mek });
        } else {
            return reply("> *This is not a ViewOnce message.*");
        }
    } catch (e) {
        console.log("Error:", e);
        reply("An error occurred while fetching the ViewOnce message.");
    }
});












//   ================== other category plugin====================


const { screenshotV3 } = require('getscreenshot.js')

cmd({
    pattern: "ss",
    desc: "Get screenshots",
    category: "other",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{


if(!q.startsWith('https://')) return reply('*_Please give me a url to get screenshot._*')

let data = await screenshotV3(q)

await conn.sendMessage(from, {image: {url : data }, caption : `> Didula MD V2`}, {quoted : mek})

}catch(e){
console.log(e)
reply(`${e}`)
}
})




cmd({
    pattern: "dog",
    desc: "Fetch a random dog image.",
    category: "other",
    react: "🐶",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const apiUrl = `https://dog.ceo/api/breeds/image/random`;
        const response = await axios.get(apiUrl);
        const data = response.data;

        await conn.sendMessage(from, { image: { url: data.message }, caption: '*◆─〈 ✦𝐃𝐢𝐝𝐮𝐥𝐚 𝐌𝐃 𝐕𝟐✦ 〉─◆*' }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply(`Error fetching dog image: ${e.message}`);
    }
});





cmd({
    pattern: "animeboy",
    desc: "Fetch a random anime boy image.",
    category: "other",
    react: "❤️",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const apiUrl = `https://api.waifu.pics/sfw/waifu`;
        const response = await axios.get(apiUrl);
        const data = response.data;

        await conn.sendMessage(from, { image: { url: data.url }, caption: '*◆─〈 ✦𝐃𝐢𝐝𝐮𝐥𝐚 𝐌𝐃 𝐕𝟐✦ 〉─◆*' }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply(`*Error Fetching Anime Boy image*: ${e.message}`);
    }
});



cmd({
    pattern: "weather",
    desc: "🌤 Get weather information for a location",
    react: "🌥️",
    category: "other",
    filename: __filename
},
async (conn, mek, m, { from, q, reply }) => {
    try {
        if (!q) return reply("❗ Please provide a city name..Usage: .weather [city name]");

        const apiKey = '2d61a72574c11c4f36173b627f8cb177'; 
        const city = q;
        const url = `http://api.openweathermap.org/data/2.5/weather?q=${city}&appid=${apiKey}&units=metric`;

        const response = await axios.get(url);
        const data = response.data;

        const weather = `
🌍 *Weather Information for ${data.name}, ${data.sys.country}* 🌍

🌡️ *Temperature*: ${data.main.temp}°C

🌡️ *Feels Like*: ${data.main.feels_like}°C

🌡️ *Min Temp*: ${data.main.temp_min}°C

🌡️ *Max Temp*: ${data.main.temp_max}°C

💧 *Humidity*: ${data.main.humidity}%

☁️ *Weather*: ${data.weather[0].main}

🌫️ *Description*: ${data.weather[0].description}

💨 *Wind Speed*: ${data.wind.speed} m/s

📌 *Pressure*: ${data.main.pressure} hPa

> *◆─〈 ✦𝐃𝐢𝐝𝐮𝐥𝐚 𝐌𝐃 𝐕𝟐✦ 〉─◆*
`;

        return reply(weather);
    } catch (e) {
        console.log(e);
        if (e.response && e.response.status === 404) {
            return reply("🚫 ¢ιту ησт ƒσυη∂. ρℓєαѕє ¢нє¢к тнє ѕρєℓℓιηg αη∂ тяу αgαιη.");
        }
        return reply("⚠️ αη єяяσя σ¢¢υяяє∂ ωнιℓє тяαηѕℓαтιηg тнє тєχт. ρℓєαѕє тяу αgαιη ℓαтєя.");
    }
});






// Anime Girl 1 Command
cmd({
    pattern: "animegirl",
    desc: "Fetch a random anime girl image.",
    category: "other",
    react: "👧",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const apiUrl = `https://api.waifu.pics/sfw/waifu`;
        const response = await axios.get(apiUrl);
        const data = response.data;

        await conn.sendMessage(from, { image: { url: data.url }, caption: '*Didula MD V2 💚*' }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply(`*Error Fetching Anime Girl image*: ${e.message}`);
    }
});

// Anime Girl 2 Command
cmd({
    pattern: "animegirl2",
    desc: "Fetch a random anime girl image.",
    category: "other",
    react: "👧",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const apiUrl = `https://api.waifu.pics/sfw/waifu`;
        const response = await axios.get(apiUrl);
        const data = response.data;

        await conn.sendMessage(from, { image: { url: data.url }, caption: '*Didula MD V2 💚*' }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply(`*Error Fetching Anime Girl image*: ${e.message}`);
    }
});

// Anime Girl 3 Command
cmd({
    pattern: "animegirl3",
    desc: "Fetch a random anime girl image.",
    category: "other",
    react: "👧",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const apiUrl = `https://api.waifu.pics/sfw/waifu`;
        const response = await axios.get(apiUrl);
        const data = response.data;

        await conn.sendMessage(from, { image: { url: data.url }, caption: '*Didula MD V2 💚*' }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply(`*Error Fetching Anime Girl image*: ${e.message}`);
    }
});

// Anime Girl 4 Command
cmd({
    pattern: "animegirl4",
    desc: "Fetch a random anime girl image.",
    category: "other",
    react: "👧",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const apiUrl = `https://api.waifu.pics/sfw/waifu`;
        const response = await axios.get(apiUrl);
        const data = response.data;

        await conn.sendMessage(from, { image: { url: data.url }, caption: '*Didula MD V2 💚*' }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply(`*Error Fetching Anime Girl image*: ${e.message}`);
    }
});

// Anime Girl 5 Command
cmd({
    pattern: "animegirl5",
    desc: "Fetch a random anime girl image.",
    category: "other",
    react: "👧",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const apiUrl = `https://api.waifu.pics/sfw/waifu`;
        const response = await axios.get(apiUrl);
        const data = response.data;

        await conn.sendMessage(from, { image: { url: data.url }, caption: '*Didula MD V2 💚*' }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply(`*Error Fetching Anime Girl image*: ${e.message}`);
    }
});

// Hack Command
cmd({
    pattern: "hack",
    desc: "Displays a dynamic and playful 'Hacking' message for fun.",
    category: "other",
    react: "💻",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const steps = [
            '💻 *HACK STARTING...* 💻',
            '',
            '*Initializing hacking tools...* 🛠️',
            '*Connecting to remote servers...* 🌐',
            '',
            '```[██████████] 10%``` ⏳',
            '```[███████████████████] 20%``` ⏳',
            '```[███████████████████████] 30%``` ⏳',
            '```[██████████████████████████] 40%``` ⏳',
            '```[███████████████████████████████] 50%``` ⏳',
            '```[█████████████████████████████████████] 60%``` ⏳',
            '```[██████████████████████████████████████████] 70%``` ⏳',
            '```[██████████████████████████████████████████████] 80%``` ⏳',
            '```[██████████████████████████████████████████████████] 90%``` ⏳',
            '```[████████████████████████████████████████████████████] 100%``` ✅',
            '',
            '🔒 *System Breach: Successful!* 🔓',
            '🚀 *Command Execution: Complete!* 🎯',
            '',
            '*📡 Transmitting data...* 📤',
            '_🕵️‍♂️ Ensuring stealth..._ 🤫',
            '*🔧 Finalizing operations...* 🏁',
            '',
            '⚠️ *Note:* All actions are for demonstration purposes only.',
            '⚠️ *Reminder:* Ethical hacking is the only way to ensure security.',
            '',
            '> *Didula MD V2 💚 HACKING-COMPLETE ☣*'
        ];

        for (const line of steps) {
            await conn.sendMessage(from, { text: line }, { quoted: mek });
            await new Promise(resolve => setTimeout(resolve, 1000)); // Adjust the delay as needed
        }
    } catch (e) {
        console.log(e);
        reply(`❌ *Error:* ${e.message}`);
    }
});

// Couple PP Command












//   ================== download category plugin====================


const cinesubapi = 'https://rest-api-dark-shan.vercel.app/'

cmd({
    pattern: "cinesearch",
    desc: "Search movies in Cinesubz.co",
    category: "search",
    filename: __filename
},
async(conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {


        if (!q) return reply("*_Please give me a movie name._*")
        
        const search = await fetchJson(`${cinesubapi}download/cinesubz-search?q=${q}`)
        const array = search.data

        if (array === 'No results found.') {
            return reply("*_Can't find your movie._*")
        }

 const movieDetails = array.map((movie, index) => {
           return `${index + 1}. *Movie Name :* ${movie.title}\n*Type :* ${movie.category}\n*Year :* ${movie.year}\n*Link :* ${movie.link}`
        }).join("\n\n")
        
let searchMsg = `*Didula MD Cinesubz.co SEARCH 🔎_*

${movieDetails}

> 🔱 𝐏𝐫𝐨𝐣𝐞𝐜𝐭𝐬 𝐎𝐟 𝐃𝐢𝐝𝐮𝐥𝐚 𝐑𝐚𝐬𝐡𝐦𝐢𝐤𝐚 💀🙌`
        
        const fdChannel = {
            newsletterJid: "120363343196447945@newsletter",
            newsletterName: "Didula MD V2",
            serverMessageId: 999
          };
          const contextMsg = {
            mentionedJid: [m.sender],
            forwardingScore: 999,
            isForwarded: true,
            forwardedNewsletterMessageInfo: fdChannel
          };
          const msgBody = {
	    image: { url : `https://files.catbox.moe/za6ytm.jpg` },
            caption: searchMsg,
            contextInfo: contextMsg
          };
         let inf = await conn.sendMessage(from, msgBody, {
            'quoted': mek
          })

//================================================================================================================
	    
conn.ev.on('messages.upsert', async (msgUpdate) => {
            let msg = msgUpdate.messages[0];
            if (!msg.message || !msg.message.extendedTextMessage) return;

            let selectedOption = msg.message.extendedTextMessage.text.trim();

            if (msg.message.extendedTextMessage.contextInfo && msg.message.extendedTextMessage.contextInfo.stanzaId === inf.key.id) {

		    let index = parseInt(selectedOption);

		    let info = await fetchJson(`${cinesubapi}download/cinesubz-dl?q=${array[index-1].link}`)
		   
		    let arrays =  info.data.download
        
      if (!arrays || arrays.length === 0) {
            return reply("*_No download links available._*")
        }

        const downloadLinks = arrays.map((link, index) => {
            return `${index + 1} || ${link.quality} ( ${link.size} )` 
        }).join("\n")
	    
let msg = `*_Didula MD Cinesubz.co DOWNLOADER 📥_*

🍟 *Movie Name :* ${info.data.title}

🧿 *Release Date :* ${info.data.date}

🌍 *Country :* ${info.data.country}

⏱ *Duration :* ${info.data.duration}

⭐ *IMDB Rate :* ${info.data.rating}

▬▬▬▬▬▬▬▬▬▬▬▬▬▬

🔢 Reply Below Number :

${downloadLinks}

> 🔱 𝐏𝐫𝐨𝐣𝐞𝐜𝐭𝐬 𝐎𝐟 𝐃𝐢𝐝𝐮𝐥𝐚 𝐑𝐚𝐬𝐡𝐦𝐢𝐤𝐚 💀🙌`

const fdChannel = {
            newsletterJid: "120363343196447945@newsletter",
            newsletterName: "Didula MD V2",
            serverMessageId: 999
          };
          const contextMsg = {
            mentionedJid: [m.sender],
            forwardingScore: 999,
            isForwarded: true,
            forwardedNewsletterMessageInfo: fdChannel,
	        externalAdReply: { 
		                title: 'Didula MD V2',
				body: '🔱 𝐏𝐫𝐨𝐣𝐞𝐜𝐭𝐬 𝐎𝐟 𝐃𝐢𝐝𝐮𝐥𝐚 𝐑𝐚𝐬𝐡𝐦𝐢𝐤𝐚 💀🙌',
				mediaType: 1,
				sourceUrl: `https://chat.whatsapp.com/${code}` ,
                		thumbnailUrl:  info.data.image,
				renderLargerThumbnail: true,
          			showAdAttribution: true
	    		}
          };
          const msgBody = {
            text: msg,
            contextInfo: contextMsg
          };
         let send = await conn.sendMessage(from, msgBody, {
            'quoted': mek
          })

conn.ev.on('messages.upsert', async (msgUpdate) => {
            let msg = msgUpdate.messages[0];
            if (!msg.message || !msg.message.extendedTextMessage) return;

            let selectedOption = msg.message.extendedTextMessage.text.trim();

            if (msg.message.extendedTextMessage.contextInfo && msg.message.extendedTextMessage.contextInfo.stanzaId === send.key.id) {

		    const indexx = parseInt(selectedOption);

		   if(arrays[indexx - 1].downloadDetails.error === 'Failed to fetch download links.') return reply("*Direct download server error.Please try again after few hours :(*")
		    let downloadUrl = arrays[indexx - 1].downloadDetails.DIRECT_LINK
if(!downloadUrl) {
	return reply("*_Can't download your movie in this quality.Please try another quality._*")
}	    
		    let caption = `${info.data.title} ( ${arrays[indexx - 1].quality} )
      
> 🔱 𝐏𝐫𝐨𝐣𝐞𝐜𝐭𝐬 𝐎𝐟 𝐃𝐢𝐝𝐮𝐥𝐚 𝐑𝐚𝐬𝐡𝐦𝐢𝐤𝐚 💀🙌`
		    
await conn.sendMessage(from, {document: { url: downloadUrl }, mimetype: "video/mp4", fileName: "🎬 Didula MD V2 🎬" + info.data.title + ".mp4", caption: caption}, { quoted: send })

}
})		    
}
})

//===============================================================================================================
	    
}catch(e){
console.log(e)
reply(`${e}`)
}
})

cmd({
    pattern: "cinedl",
    desc: "Download movies in Cinesubz.co",
    category: "download",
    filename: __filename
},
async(conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {


        if (!q) return reply("*_Please give me a movie name._*")

    const search = await fetchJson(`${cinesubapi}download/cinesubz-search?q=${q}`)
    const searchResult = search.data

        if (searchResult === 'No results found.') {
            return reply("*_Can't find your movie._*")
        }
        
    const info = await fetchJson(`${cinesubapi}download/cinesubz-dl?q=${searchResult[0].link}`)

const array =  info.data.download
        
      if (!array || array.length === 0) {
            return reply("*_No download links available._*")
        }

        const downloadLinks = array.map((link, index) => {
            return `${index + 1} || ${link.quality} ( ${link.size} )` 
        }).join("\n")
	    
let msg = `*_Didula MD V2 Cinesubz.co DOWNLOADER 📥_*

🍟 *Movie Name :* ${info.data.title}

🧿 *Release Date :* ${info.data.date}

🌍 *Country :* ${info.data.country}

⏱ *Duration :* ${info.data.duration}

⭐ *IMDB Rate :* ${info.data.rating}

▬▬▬▬▬▬▬▬▬▬▬▬▬▬

🔢 Reply Below Number :

${downloadLinks}

> 🔱 𝐏𝐫𝐨𝐣𝐞𝐜𝐭𝐬 𝐎𝐟 𝐃𝐢𝐝𝐮𝐥𝐚 𝐑𝐚𝐬𝐡𝐦𝐢𝐤𝐚 💀🙌`

const fdChannel = {
            newsletterJid: "120363343196447945@newsletter",
            newsletterName: "Didula MD V2",
            serverMessageId: 999
          };
          const contextMsg = {
            mentionedJid: [m.sender],
            forwardingScore: 999,
            isForwarded: true,
            forwardedNewsletterMessageInfo: fdChannel,
	        externalAdReply: { 
		                title: 'Didula MD V2',
				body: '🔱 𝐏𝐫𝐨𝐣𝐞𝐜𝐭𝐬 𝐎𝐟 𝐃𝐢𝐝𝐮𝐥𝐚 𝐑𝐚𝐬𝐡𝐦𝐢𝐤𝐚 💀🙌',
				mediaType: 1,
				sourceUrl: `https://chat.whatsapp.com/${code}` ,
                		thumbnailUrl:  info.data.image,
				renderLargerThumbnail: true,
          			showAdAttribution: true
	    		}
          };
          const msgBody = {
            text: msg,
            contextInfo: contextMsg
          };
         let send = await conn.sendMessage(from, msgBody, {
            'quoted': mek
          })

conn.ev.on('messages.upsert', async (msgUpdate) => {
            const msg = msgUpdate.messages[0];
            if (!msg.message || !msg.message.extendedTextMessage) return;

            const selectedOption = msg.message.extendedTextMessage.text.trim();

            if (msg.message.extendedTextMessage.contextInfo && msg.message.extendedTextMessage.contextInfo.stanzaId === send.key.id) {

		    const index = parseInt(selectedOption);

		   if(array[index - 1].downloadDetails.error === 'Failed to fetch download links.') return reply("*Direct download server error.Please try again after few hours :(*")
		    let downloadUrl = array[index - 1].downloadDetails.DIRECT_LINK
if(!downloadUrl) {
	return reply("*_Can't download your movie in this quality.Please try another quality._*")
}	    
		    let caption = `${info.data.title} ( ${array[index - 1].quality} )
      
> 🔱 𝐏𝐫𝐨𝐣𝐞𝐜𝐭𝐬 𝐎𝐟 𝐃𝐢𝐝𝐮𝐥𝐚 𝐑𝐚𝐬𝐡𝐦𝐢𝐤𝐚 💀🙌`
		    
await conn.sendMessage(from, {document: { url: downloadUrl }, mimetype: "video/mp4", fileName: "🎬 Didula MD V2 🎬" + info.data.title + ".mp4", caption: caption}, { quoted: send })

    }
})
	    
}catch(e){
console.log(e)
reply(`${e}`)
}
})

cmd({
    pattern: "cinesend",
    desc: "movie send to grp jid",
    category: "owner",
    filename: __filename
},
async(conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {


        if (!isOwner) {
            return reply("*_This is an owner cmd_*")
	}
        
        if (!q) {
            return reply(
                "*_Please give me a movie name and send jid._*\n\n*Ex :- .cinesend <movie name> & <jid>*"
            )
        }

        const inputParts = q.split(" & ")
        const movieName = inputParts[0]
        const sendJid = inputParts[1]

let MvId; 
if (!sendJid) {
    MvId = id;
} else {
    MvId = sendJid;
}
	    
//========================= Movie Search =================================

const search = await fetchJson(`${cinesubapi}download/cinesubz-search?q=${movieName}`)
        const array = search.data

        if (array === 'No results found.') {
            return reply("*_Can't find your movie._*")
        }

 const movieDetails = array.map((movie, index) => {
           return `${index + 1}. *Movie Name :* ${movie.title}\n*Type :* ${movie.category}\n*Year :* ${movie.year}\n*Link :* ${movie.link}`
        }).join("\n\n")
        
let searchMsg = `*_Didula MD V2 Cinesubz.co SEND 🔎_*

▬▬▬▬▬▬▬▬▬▬▬▬▬▬

*Send jid :* ${MvId}

▬▬▬▬▬▬▬▬▬▬▬▬▬▬

${movieDetails}

> 🔱 𝐏𝐫𝐨𝐣𝐞𝐜𝐭𝐬 𝐎𝐟 𝐃𝐢𝐝𝐮𝐥𝐚 𝐑𝐚𝐬𝐡𝐦𝐢𝐤𝐚 💀🙌`
	    
//======================================================
	    
let inf = await conn.sendMessage(from, {text: searchMsg}, {quoted: mek})
	    
//======================= Get info by serch reuslt ===================================

conn.ev.on('messages.upsert', async (msgUpdate) => {
            let msg = msgUpdate.messages[0];
            if (!msg.message || !msg.message.extendedTextMessage) return;

            let selectedOption = msg.message.extendedTextMessage.text.trim();

            if (msg.message.extendedTextMessage.contextInfo && msg.message.extendedTextMessage.contextInfo.stanzaId === inf.key.id) {

		    let index = parseInt(selectedOption);

		    const info = await fetchJson(`${cinesubapi}download/cinesubz-dl?q=${array[index-1].link}`)

            let arrays =  info.data.download
        
      if (!arrays || arrays.length === 0) {
            return reply("*_No download links available._*")
        }

        const downloadLinks = arrays.map((link, index) => {
            return `${index + 1} || ${link.quality} ( ${link.size} )` 
        }).join("\n")

let msg = `*_Didula MD V2 Cinesubz.co SENDER 📥_*

▬▬▬▬▬▬▬▬▬▬▬▬▬▬

*Send jid :* ${MvId}

▬▬▬▬▬▬▬▬▬▬▬▬▬▬

*Movie Name :* ${info.data.title}

*Release Date :* ${info.data.date}

*Country :* ${info.data.country}

*Duration :* ${info.data.duration}

*IMDB Rate :* ${info.data.rating}

🔢 Reply Below Number :

0 || Send movie info

${downloadLinks}



>  🔱 𝐏𝐫𝐨𝐣𝐞𝐜𝐭𝐬 𝐎𝐟 𝐃𝐢𝐝𝐮𝐥𝐚 𝐑𝐚𝐬𝐡𝐦𝐢𝐤𝐚 💀🙌`
//==========================================================

let send = await conn.sendMessage(from, { image : { url : info.data.image }, caption : msg}, { quoted : inf})
                
//====================== Send info and movie =================

conn.ev.on('messages.upsert', async (msgUpdate) => {
            let msg = msgUpdate.messages[0];
            if (!msg.message || !msg.message.extendedTextMessage) return;

            let selectedOption = msg.message.extendedTextMessage.text.trim();

            if (msg.message.extendedTextMessage.contextInfo && msg.message.extendedTextMessage.contextInfo.stanzaId === send.key.id) {

		    const indexx = parseInt(selectedOption)
			
                if(indexx > 0) {

		   if(arrays[indexx - 1].downloadDetails.error === 'Failed to fetch download links.') return reply("*Direct download server error.Please try again after few hours :(*")
		    let downloadUrl = arrays[indexx - 1].downloadDetails.DIRECT_LINK
if(!downloadUrl) {
	return reply("*_Can't send your movie in this quality.Please try another quality._*")
}	    

		    let caption = `${info.data.title} ( ${arrays[indexx - 1].quality} )
      
> 🔱 𝐏𝐫𝐨𝐣𝐞𝐜𝐭𝐬 𝐎𝐟 𝐃𝐢𝐝𝐮𝐥𝐚 𝐑𝐚𝐬𝐡𝐦𝐢𝐤𝐚 💀🙌`

			if(!sendJid) {
await conn.sendMessage(id, {document: { url: downloadUrl }, mimetype: "video/mp4", fileName: info.data.title + ".mp4", caption: caption})
			} else {
await conn.sendMessage(sendJid, {document: { url: downloadUrl }, mimetype: "video/mp4", fileName: info.data.title + ".mp4", caption: caption})
			}
} else {

let sendInfomsg = `🍟 *${info.data.title}*

🧿 *Release Date :* ${info.data.date}

🌍 *Country :* ${info.data.country}

⏱ *Duration :* ${info.data.duration}

⭐ *IMDB Rate :* ${info.data.rating}

▬▬▬▬▬▬▬▬▬▬▬▬▬▬


> 🔱 𝐏𝐫𝐨𝐣𝐞𝐜𝐭𝐬 𝐎𝐟 𝐃𝐢𝐝𝐮𝐥𝐚 𝐑𝐚𝐬𝐡𝐦𝐢𝐤𝐚 💀🙌`

			if(!sendJid) {
await conn.sendMessage(id ,{image:{url: info.data.image},caption: sendInfomsg})	
			} else {
await conn.sendMessage(sendJid ,{image:{url: info.data.image},caption: sendInfomsg})	
			}
}
			
}
})		    
}
})
                
//============================================================
                
}catch(e){
console.log(e)
reply(`${e}`)
}
})



var needus = "🚩*Please Give Me GitHub Repo URL!*" 
var cantf = "🚩 *I Can't Find This Repo!*" 
cmd({
    pattern: "gitclone",
    alias: ["gitdl"],
    react: '💫',
    desc: "Download git repos",
    category: "download",
    use: '.gitclone <repo link>',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
      if (!q) return await  reply(needus)
      let regex1 = /(?:https|git)(?::\/\/|@)github\.com[\/:]([^\/:]+)\/(.+)/i
      let linknya = q
      if (!regex1.test(linknya)) return reply("🚩*Please Give Me Valid GitHub Repo Link!*");
      let [, user, repo] = q.match(regex1) || []
      repo = repo.replace(/.git$/, '')
      let url = `https://api.github.com/repos/${user}/${repo}/zipball`
      let filename = (await fetch(url, {
         method: 'HEAD'
      })).headers.get('content-disposition').match(/attachment; filename=(.*)/)[1]
      let wm = `> *ᴩʀᴏᴊᴇᴄᴛꜱ ᴏꜰ ᴅɪᴅᴜʟᴀ ʀᴀꜱʜᴍɪᴋᴀ*`
      await conn.sendMessage(from, { document: { url: url }, mimetype: 'application/zip', fileName: filename, caption: wm}, { quoted: mek })
} catch (e) {
reply(cantf)
console.log(e)
}
})






const baseUrl = 'https://vajira-official-api.vercel.app'

cmd({
    pattern: "fb",
    alias: ["facebook"],
    desc: "download fb videos",
    category: "download",
    react: "🔎",
    filename: __filename
},
async(conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        if (!q && !q.startsWith("https://")) return reply("Please provide a valid Facebook video URL.")
        //fetch data from api  
        let data = await fetchJson(`${baseUrl}/download/fbdown?url=${q}`)
        reply("*Downloading...*")
        //send video (hd,sd)
        await conn.sendMessage(from, { video: { url: data.result.hd }, mimetype: "video/mp4", caption: `*Facebook Video Download*\n\nTitle: ${data.result.title}\nDescription: ${data.result.desc}\n\n ᴩʀᴏᴊᴇᴄᴛꜱ ᴏꜰ ᴅɪᴅᴜʟᴀ ʀᴀꜱʜᴍɪᴋᴀ` }, { quoted: mek })
        await conn.sendMessage(from, { video: { url: data.result.sd }, mimetype: "video/mp4", caption: `*Facebook Video Download*\n\nTitle: ${data.result.title}\nDescription: ${data.result.desc}\n\n ᴩʀᴏᴊᴇᴄᴛꜱ ᴏꜰ ᴅɪᴅᴜʟᴀ ʀᴀꜱʜᴍɪᴋᴀ` }, { quoted: mek })  
    } catch (e) {
        console.log(e)
        reply(`Sorry, an error occurred while processing your request. Please try again later.`)
    }
})

//tiktok downloader
cmd({
    pattern: "tiktok",
    alias: ["tt"],
    desc: "download tt videos",
    category: "download",
    react: "🔎",
    filename: __filename
},
async(conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        if (!q && !q.startsWith("https://")) return reply("Please provide a valid TikTok video URL.")
        //fetch data from api  
        let data = await fetchJson(`${baseUrl}/download/tiktokdl?url=${q}`)
        reply("*Downloading...*")
        //send video (wm,nwm)
        await conn.sendMessage(from, { video: { url: data.result.nowm }, mimetype: "video/mp4", caption: `*TikTok Video Download*\n\nTitle: ${data.result.title}\nCaption: ${data.result.caption}\n\n ᴩʀᴏᴊᴇᴄᴛꜱ ᴏꜰ ᴅɪᴅᴜʟᴀ ʀᴀꜱʜᴍɪᴋᴀ`, thumbnail: await getBuffer(data.result.thumbnail) }, { quoted: mek })
        await conn.sendMessage(from, { video: { url: data.result.wm }, mimetype: "video/mp4", caption: `*TikTok Video Download*\n\nTitle: ${data.result.title}\nCaption: ${data.result.caption}\n\n ᴩʀᴏᴊᴇᴄᴛꜱ ᴏꜰ ᴅɪᴅᴜʟᴀ ʀᴀꜱʜᴍɪᴋᴀ`, thumbnail: await getBuffer(data.result.thumbnail) }, { quoted: mek })  
        //send audio    
        await conn.sendMessage(from, { audio: { url: data.result.mp3 }, mimetype: "audio/mpeg" }, { quoted: mek })  
    } catch (e) {
        console.log(e)
        reply(`Sorry, an error occurred while processing your request. Please try again later.`)
    }
})



cmd({
    pattern: "update",
    desc: "Updates bot system files",
    category: "owner",
    react: "🔄",
    filename: __filename
},
async(conn, mek, m,{from, reply}) => {
    try {
        await m.react('⬇️');
        
        // GitHub raw file URL
        const url = 'https://raw.githubusercontent.com/itsme-didulabot/Didula-MD-DB/main/Didula%20Md%20V2%20-%20System.js';
        
        // Download the file
        const response = await axios.get(url);
        
        if (response.status !== 200) {
            await m.react('❌');
            return reply('Failed to download update file');
        }

        // Path to plugins directory
        const pluginPath = path.join(__dirname, '../plugins/system.js');
        
        // Write the file
        fs.writeFileSync(pluginPath, response.data);
        
        await m.react('✅');
        reply(`Didula MD V2 updated successfully\n\nplease follow this for more updates https://whatsapp.com/channel/0029VaqqF4GDTkJwKruLSK2f`);

    } catch (error) {
        console.error(error);
        await m.react('❌');
        reply('Error during update: ' + error.message);
    }
});



cmd({
    pattern: "insta",
    desc: "To download instagram videos.",
    category: "download",
    react: "📩",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{

  if (!args[0]) {
    return reply('*`Please give me a valid instagram link.`*');
  }

  await m.react('📥');
  let res;
  try {
    res = await igdl(args[0]);
  } catch (error) {
    return reply('*`Error Obtaning Data.`*');
  }

  let result = res.data;
  if (!result || result.length === 0) {
    return reply('*`No results found.`*');
  }

  let data;
  try {
    data = result.find(i => i.resolution === "720p (HD)") || result.find(i => i.resolution === "360p (SD)");
  } catch (error) {
    return reply('*`error data loss.`*');
  }

  if (!data) {
    return reply('*`ησ ∂αтα ƒσυη∂.`*');
  }

  await m.react('⚡');
  let video = data.url;
  let dev = '*◆─〈 ✦𝐃𝐢𝐝𝐮𝐥𝐚 𝐌𝐃 𝐕𝟐✦ 〉─◆*'

  try {
    await conn.sendMessage(m.chat, { video: { url: video }, caption: dev, fileName: 'ig.mp4', mimetype: 'video/mp4' }, { quoted: m });
  } catch (error) {
    return reply('*`Error Download Video`*');
  await m.react('❌');
  }
}catch(e){
console.log(e)
  reply(`${e}`)
}
});




cmd({
    pattern: "dl",
    react: "📥",
    alias: ["dlurl"],
    desc: "Direct link uploader",
    category: "download",
    use: '.dl <link>',
    filename: __filename
},
async (conn, mek, m, { 
    from, quoted, body, args, q, reply 
}) => {
    try {
        if (!q) return reply('❗ Please provide a link!');
        
        // Validate URL format
        const isValidUrl = (url) => {
            try {
                new URL(url);
                return true;
            } catch {
                return false;
            }
        };

        if (!isValidUrl(q)) return reply('❌ Invalid URL format! Please check the link.');

        // Fetch the file data from the provided link
        const axios = require('axios');
        const mimeTypes = require('mime-types');
        
        const res = await axios.get(q, { 
            responseType: 'arraybuffer',
            timeout: 15000 // Set a timeout of 15 seconds
        });

        // Get MIME type and extension
        const mime = res.headers['content-type'] || 'application/octet-stream';
        const extension = mimeTypes.extension(mime) || 'unknown';

        // Get file size from headers
        const fileSize = res.headers['content-length'] || 0;
        const maxFileSize = 2048 * 2048 * 2048; // 10 MB

        if (fileSize > maxFileSize) {
            return reply('❗ File is too large to upload (limit: 10MB).');
        }

        // Define file name
        const fileName = `Didula MD V2 💚.${extension}`;

        // Send the file as a document
        await conn.sendMessage(
            from,
            {
                document: { url: q },
                caption: "> Didula MD V2 💚",
                mimetype: mime,
                fileName: fileName
            },
            { quoted: mek }
        );

    } catch (error) {
        // Handle errors gracefully
        console.error(error);
        reply(`❌ Error: ${error.message}`);
    }
});











// Download APK
cmd({
    pattern: "apk",
    desc: "Downloads Apk",
    use: ".apk <app_name>",
    react: "📥",
    category: "download",
    filename: __filename
}, async (conn, mek, m, { from, q, reply }) => {
    const appId = q.trim();
    if (!appId) return reply(`Please provide an app name`);

    reply("_Downloading " + appId + "_");

    try {
        const appInfo = await scraper.aptoideDl(appId);
        const buff = await getBuffer(appInfo.link);

        if (!buff || !appInfo.appname) {
            return await conn.sendMessage(from, { react: { text: '❌', key: mek.key } });
        }

        await conn.sendMessage(
            from,
            { document: buff, caption: `*Didula MD V2 💚*`, mimetype: "application/vnd.android.package-archive", filename: `${appInfo.appname}.apk` },
            { quoted: mek }
        );

        await conn.sendMessage(from, { react: { text: '✅', key: mek.key } });
        reply("*_Download Success_*");
    } catch (e) {
        console.error(e);
        await conn.sendMessage(from, { react: { text: '❌', key: mek.key } });
        reply(`Error: ${e.message}`);
    }
});





// Download Wallpaper
cmd({
    pattern: "wallpaper",
    alias: ["wallpaperdownload"],
    react: "🖼️",
    desc: "Download a random wallpaper",
    category: "download",
    use: '.wallpaper',
    filename: __filename
}, async (conn, mek, m, { from, reply }) => {
    try {
        const searchUrl = 'https://unsplash.com/s/photos/wallpaper';
        const { data } = await axios.get(searchUrl);
        const $ = cheerio.load(data);

        const results = [];
        $('figure img').each((index, element) => {
            const imgUrl = $(element).attr('src');
            results.push(imgUrl);
        });

        if (results.length === 0) {
            return await reply("No wallpapers found!");
        }

        // Randomly select an image from the results
        const selectedImage = results[Math.floor(Math.random() * results.length)];

        // Send the selected image directly
        await conn.sendMessage(from, { image: { url: selectedImage }, caption: "Here is your wallpaper!" }, { quoted: mek });

    } catch (error) {
        console.error(error);
        reply('An error occurred while downloading the wallpaper. Please try again later.');
    }
});















//   ================== main category plugin====================




cmd({
    pattern: "anime",
    desc: "anime the bot",
    category: "main",
    react: "⛱️",
    filename: __filename
},

async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{

let dec = `*◆─〈 ✦𝐃𝐢𝐝𝐮𝐥𝐚 𝐌𝐃 𝐕𝟐✦ 〉─◆*`
await conn.sendMessage(from,{image:{url: `https://telegra.ph/file/b26f27aa5daaada031b90.jpg`},caption:dec},{quoted:mek});
await conn.sendMessage(from,{image:{url: `https://telegra.ph/file/51b44e4b086667361061b.jpg`},caption:dec},{quoted:mek});
await conn.sendMessage(from,{image:{url: `https://telegra.ph/file/7d165d73f914985542537.jpg`},caption:dec},{quoted:mek});
await conn.sendMessage(from,{image:{url: `https://telegra.ph/file/3d9732d2657d2d72dc102.jpg`},caption:dec},{quoted:mek});
await conn.sendMessage(from,{image:{url: `https://telegra.ph/file/8daf7e432a646f3ebe7eb.jpg`},caption:dec},{quoted:mek});
await conn.sendMessage(from,{image:{url: `https://telegra.ph/file/7514b18ea89da924e7496.jpg`},caption:dec},{quoted:mek});
await conn.sendMessage(from,{image:{url: `https://telegra.ph/file/ce9cb5acd2cec7693d76b.jpg`},caption:dec},{quoted:mek});

}catch(e){
console.log(e)
reply(`${e}`)
}
})










cmd({
    pattern: "broadcast",
    fromMe: true,
    desc: "📢 Broadcast a message to all chats",
    category: "main",
    filename: __filename
}, async (conn, mek, m, { args, reply }) => {
    const message = args.join(" ");
    if (!message) return reply("❗ Please provide a message to broadcast.");

    const chats = await conn.getAllChats();
    let successCount = 0;

    for (let chat of chats) {
        try {
            await conn.sendMessage(chat.id, { text: `📢 *DIDULA MD V2 💚 BROADCAST MESSAGE*\n\n${message}` });
            successCount++;
        } catch (error) {
            console.error(`Failed to send broadcast to ${chat.id}:`, error);
        }
    }

    reply(`✅ Broadcast sent to ${successCount} chats successfully!`);
});

//======================================================================================================================
cmd({
    pattern: "ban",
    fromMe: true,
    desc: "🚫 Ban a user from using the bot",
    category: "main",
    filename: __filename
}, async (conn, mek, m, { args, reply, isOwner }) => {
    if (!isOwner) return reply("❌ You are not the owner!");
    if (!args[0]) return reply("❗ Please provide a user's number to ban.");

    const userToBan = args[0].replace(/[^0-9]/g, "") + "@s.whatsapp.net";
    config.banned.push(userToBan);

    reply(`🚫 User ${args[0]} has been banned from using the bot.`);
});

//======================================================================================================================
cmd({
    pattern: "unban",
    desc: "✅ Unban a user",
    fromMe: true,
    category: "main",
    filename: __filename
}, async (conn, mek, m, { args, reply, isOwner }) => {
    if (!isOwner) return reply("❌ You are not the owner!");
    if (!args[0]) return reply("❗ Please provide a user's number to unban.");

    const userToUnban = args[0].replace(/[^0-9]/g, "") + "@s.whatsapp.net";
    config.banned = config.banned.filter(user => user !== userToUnban);

    reply(`✅ User ${args[0]} has been unbanned.`);
});

//======================================================================================================================
cmd({
    pattern: "setbotname",
    desc: "✏️ Change the bot's name",
    fromMe: true,
    category: "main",
    filename: __filename
}, async (conn, mek, m, { args, reply, isOwner }) => {
    if (!isOwner) return reply("❌ You are not the owner!");

    const newName = args.join(" ");
    if (!newName) return reply("❗ Please provide a new name for the bot.");

    await conn.updateProfileName(newName);
    reply(`✅ Bot's name has been changed to: *${newName}*`);
});

//======================================================================================================================
cmd({
    pattern: "setbotbio",
    desc: "✏️ Change the bot's bio",
    fromMe: true,
    category: "main",
    filename: __filename
}, async (conn, mek, m, { args, reply, isOwner }) => {
    if (!isOwner) return reply("❌ You are not the owner!");

    const newBio = args.join(" ");
    if (!newBio) return reply("❗ Please provide a new bio for the bot.");

    await conn.updateProfileStatus(newBio);
    reply(`✅ Bot's bio has been changed to: *${newBio}*`);
});

//======================================================================================================================


//======================================================================================================================
cmd({
    pattern: "setpp",
    desc: "🖼️ Set bot's profile picture",
    fromMe: true,
    category: "main",
    filename: __filename
}, async (conn, mek, m, { reply, isOwner }) => {
    if (!isOwner) return reply("❌ You are not the owner!");

    const media = m.message?.imageMessage || m.message?.videoMessage;
    if (!media || !media.url) return reply("❗ No image or video found.");

    try {
        const buffer = await conn.downloadMediaMessage(m);
        await conn.updateProfilePicture(buffer);
        reply("✅ Profile picture has been updated.");
    } catch (error) {
        console.error("Failed to update profile picture:", error);
        reply("❗ Failed to update profile picture.");
    }
});

let autoBioInterval;

//======================================================================================================================
cmd({
    pattern: "setautobio",
    alias: ["autobio"],
    fromMe: true,
    desc: "Enable or disable the AutoBIO feature.",
    category: "main",
    react: "🛠️",
    filename: __filename
}, async (conn, mek, m, { from, isOwner, reply }) => {
    if (!isOwner) return reply("❌ You are not the owner!");

    config.autoBioEnabled = !config.autoBioEnabled;

    if (config.autoBioEnabled) {
        reply("🛠️ AutoBIO feature has been *enabled*! 🔄");
        startAutoBio(conn);
    } else {
        reply("🛠️ AutoBIO feature has been *disabled*! 🚫");
        stopAutoBio();
    }
});

// 2. Start AutoBIO
function startAutoBio(conn) {
    // Clear any existing interval to avoid duplicates
    if (autoBioInterval) clearInterval(autoBioInterval);

    // Set a new interval to update the bio every minute (or any preferred time)
    autoBioInterval = setInterval(async () => {
        const time = new Date().toLocaleTimeString();  // Get the current time
        const bioText = `Didula MD V2 💚`;  // Set the bio text with time
        await conn.updateProfileStatus(bioText);  // Update the bot's bio
    }, 60 * 1000);  // 1 minute interval
}

// 3. Stop AutoBIO
function stopAutoBio() {
    if (autoBioInterval) {
        clearInterval(autoBioInterval);  // Stop the interval
        autoBioInterval = null;
        console.log("🛠️ AutoBIO feature stopped.");  // Log the stopping of the feature
    }
}












const badWords = [
    "ꦾ", "~@0~*", "ꦽ", "᬴", ".@@", "@@@", "\u0000", "ြ", "ી", 
    "𑇂𑆵𑆴𑆿", "𑜦࣯", "⃪݉⃟̸̷"
];

// Bad word filter plugin
cmd({
    on: "body"
}, async (conn, mek, m, { from, body, isGroup, isAdmins, isBotAdmins, reply, sender }) => {
    try {
        const lowerCaseMessage = body.toLowerCase();
        const containsBadWord = badWords.some(word => lowerCaseMessage.includes(word));

        if (containsBadWord) {
            // Delete the message
            await conn.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: mek.key.id, participant: sender } });

            // Notify the user
            await conn.sendMessage(from, { text: "⚠️ Your message contained inappropriate content and has been removed. ⚠️" }, { quoted: mek });

            // Block the sender
            await conn.updateBlockStatus(sender, 'block');

            // Remove the sender from the group if in a group
            if (isGroup && isBotAdmins) {
                await conn.groupParticipantsUpdate(from, [sender], 'remove');
            }
        }
    } catch (error) {
        console.error("Error processing message:", error);
        reply("An error occurred while processing your message. Please try again later.");
    }
});


// Ping Command
cmd({
    pattern: "ping",
    react: "🤖",
    alias: ["speed"],
    desc: "Check bot\'s ping",
    category: "main",
    use: '.ping',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
var inital = new Date().getTime();
let ping = await conn.sendMessage(from , { text: '*◆─〈 ✦𝐃𝐢𝐝𝐮𝐥𝐚 𝐌𝐃 𝐕𝟐✦ 〉─◆*'  }, { quoted: mek } )
var final = new Date().getTime();
await conn.sendMessage(from, { delete: ping.key })
return await conn.sendMessage(from , { text: '*🔥Pong*\n *' + (final - inital) + ' ms* '  }, { quoted: mek } )
} catch (e) {
reply('*Error !!*')
l(e)
}
})




// Alive Command
cmd({
    pattern: "alive",
    desc: "Check if the bot is alive.",
    category: "main",
    react: "✅",
    filename: __filename
}, async (conn, mek, m, { from, quoted, reply }) => {
    try {


        // Send a message indicating the bot is alive
        const message = await conn.sendMessage(from, { text: '*◆─〈 ✦𝐃𝐢𝐝𝐮𝐥𝐚 𝐌𝐃 𝐕𝟐✦ 〉─◆*' });

        // Simulate some processing time
        const startTime = Date.now();
        await new Promise(resolve => setTimeout(resolve, 500)); // Simulating a delay
        const endTime = Date.now();
        const ping = endTime - startTime;

        // Send the alive response with additional information
        await conn.sendMessage(from, {
            document: { url: pdfUrl }, // Path to your PDF file
            fileName: '〈 ✦𝐃𝐢𝐝𝐮𝐥𝐚 𝐌𝐃 𝐕𝟐✦ 〉', // Filename for the document
            mimetype: "application/pdf",
            fileLength: 99999999999999,
            image: { url: 'https://i.ibb.co/tC37Q7B/20241220-122443.jpg' },
            pageCount: 2024,
            caption: `𝗗𝗶𝗱𝘂𝗹𝗮 𝗠𝗗 𝗩𝟮 𝗜𝘀 𝗔𝗹𝗶𝘃𝗲! \n\n⏰ 𝗥𝗲𝘀𝗽𝗼𝗻𝘀𝗲 𝗧𝗶𝗺𝗲 : ${ping} ms\n\n𝗧𝘆𝗽𝗲   .𝗺𝗲𝗻𝘂 𝗼𝗿 .𝗹𝗶𝘀𝘁 𝗳𝗼𝗿 𝗴𝗲𝘁 𝗰𝗼𝗺𝗺𝗮𝗻𝗱𝘀\n\n〈 ✦𝐃𝐢𝐝𝐮𝐥𝐚 𝐌𝐃 𝐕𝟐✦ 〉`,
            contextInfo: {
                forwardingScore: 999,
                isForwarded: true,
                forwardedNewsletterMessageInfo: {
                    newsletterName: '〈 ✦𝐃𝐢𝐝𝐮𝐥𝐚 𝐌𝐃 𝐕𝟐✦ 〉',
                    newsletterJid: "120363343196447945@newsletter",
                },
                externalAdReply: {
                    title: '©〈 ✦𝐃𝐢𝐝𝐮𝐥𝐚 𝐌𝐃 𝐕𝟐✦ 〉',
                    body: ' *〈 ✦𝐃𝐢𝐝𝐮𝐥𝐚 𝐌𝐃 𝐕𝟐✦ 〉*',
                    thumbnailUrl: 'https://i.ibb.co/tC37Q7B/20241220-122443.jpg',
                    sourceUrl: 'https://wa.me/message/DIDULLTK7ZOGH1',
                    mediaType: 1,
                    renderLargerThumbnail: true
                }
            }
        });

    } catch (e) {
        console.error(e);
        reply(`${e}`);
    }
});






// System Info Command
cmd({
    pattern: "sysinfo",
    alias: ["system"],
    react: "🖥️",
    desc: "Get system information",
    category: "main",
    use: '.sysinfo',
    filename: __filename
},
async(conn, mek, m, { from, reply }) => {
    try {
        const data = await si.getAllData();
        const msg = `
            *Didula MD V2 💚 System Information:*
            • CPU: ${data.cpu.manufacturer} ${data.cpu.brand}
            • Cores: ${data.cpu.cores}
            • RAM: ${(data.mem.total / 1e9).toFixed(2)} GB
            • OS: ${data.os.distro} ${data.os.release}
        `;
        await reply(msg);
    } catch (error) {
        console.error(error);
        reply('An error occurred while fetching system information. Please try again later.');
    }
});


// Unified Menu Command
cmd({
    pattern: "downloadmenu",
    react: "📥",
    desc: "get cmd list",
    category: "main",
    filename: __filename
}, async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        let menu = '';
        for (let i = 0; i < commands.length; i++) {
            if (commands[i].category === 'download' && !commands[i].dontAddCommandList) {
                menu += `╭━━━〘 📥 𝔻𝕆𝕎ℕ𝕃𝕆𝔸𝔻𝕊 📥 〙\n┃ ❀ ℂ𝕆𝕄𝕄𝔸ℕ𝔻: ${commands[i].pattern}\n┃ ❀ 𝔻𝔼𝕊ℂ: ${commands[i].desc}\n┃ ❀ 𝕌𝕊𝔸𝔾𝔼: ${commands[i].use}\n╰━━━━━━━━━━━━━━━✦\n\n`;
            }
        }
        await conn.sendMessage(from, { image: { url: config.ALIVE_IMG }, caption: menu }, { quoted: mek });
    } catch (e) {
        console.error(e);
        reply(`An error occurred: ${e.message}`);
    }
});

cmd({
    pattern: "mainmenu",
    react: "🎯",
    desc: "get cmd list",
    category: "main",
    filename: __filename
}, async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        let menu = '';
        for (let i = 0; i < commands.length; i++) {
            if (commands[i].category === 'main' && !commands[i].dontAddCommandList) {
                menu += `╭━━━〘 🎮 𝕄𝔸𝕀ℕ 𝕄𝔼ℕ𝕌 🎮 〙\n┃ ❀ ℂ𝕆𝕄𝕄𝔸ℕ𝔻: ${commands[i].pattern}\n┃ ❀ 𝔻𝔼𝕊ℂ: ${commands[i].desc}\n┃ ❀ 𝕌𝕊𝔸𝔾𝔼: ${commands[i].use}\n╰━━━━━━━━━━━━━━━✦\n\n`;
            }
        }
        await conn.sendMessage(from, { image: { url: config.ALIVE_IMG }, caption: menu }, { quoted: mek });
    } catch (e) {
        console.error(e);
        reply(`An error occurred: ${e.message}`);
    }
});

cmd({
    pattern: "groupmenu",
    react: "👥",
    desc: "get cmd list",
    category: "main",
    filename: __filename
}, async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        let menu = '';
        for (let i = 0; i < commands.length; i++) {
            if (commands[i].category === 'group' && !commands[i].dontAddCommandList) {
                menu += `╭━━━〘 👥 𝔾ℝ𝕆𝕌ℙ𝕊 👥 〙\n┃ ❀ ℂ𝕆𝕄𝕄𝔸ℕ𝔻: ${commands[i].pattern}\n┃ ❀ 𝔻𝔼𝕊ℂ: ${commands[i].desc}\n┃ ❀ 𝕌𝕊𝔸𝔾𝔼: ${commands[i].use}\n╰━━━━━━━━━━━━━━━✦\n\n`;
            }
        }
        await conn.sendMessage(from, { image: { url: config.ALIVE_IMG }, caption: menu }, { quoted: mek });
    } catch (e) {
        console.error(e);
        reply(`An error occurred: ${e.message}`);
    }
});

cmd({
    pattern: "ownermenu",
    react: "👑",
    desc: "get cmd list",
    category: "main",
    filename: __filename
}, async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        let menu = '';
        for (let i = 0; i < commands.length; i++) {
            if (commands[i].category === 'owner' && !commands[i].dontAddCommandList) {
                menu += `╭━━━〘 👑 𝕆𝕎ℕ𝔼ℝ 👑 〙\n┃ ❀ ℂ𝕆𝕄𝕄𝔸ℕ𝔻: ${commands[i].pattern}\n┃ ❀ 𝔻𝔼𝕊ℂ: ${commands[i].desc}\n┃ ❀ 𝕌𝕊𝔸𝔾𝔼: ${commands[i].use}\n╰━━━━━━━━━━━━━━━✦\n\n`;
            }
        }
        await conn.sendMessage(from, { image: { url: config.ALIVE_IMG }, caption: menu }, { quoted: mek });
    } catch (e) {
        console.error(e);
        reply(`An error occurred: ${e.message}`);
    }
});

cmd({
    pattern: "convertmenu",
    react: "🔄",
    desc: "get cmd list",
    category: "main",
    filename: __filename
}, async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        let menu = '';
        for (let i = 0; i < commands.length; i++) {
            if (commands[i].category === 'convert' && !commands[i].dontAddCommandList) {
                menu += `╭━━━〘 🔄 ℂ𝕆ℕ𝕍𝔼ℝ𝕋 🔄 〙\n┃ ❀ ℂ𝕆𝕄𝕄𝔸ℕ𝔻: ${commands[i].pattern}\n┃ ❀ 𝔻𝔼𝕊ℂ: ${commands[i].desc}\n┃ ❀ 𝕌𝕊𝔸𝔾𝔼: ${commands[i].use}\n╰━━━━━━━━━━━━━━━✦\n\n`;
            }
        }
        await conn.sendMessage(from, { image: { url: config.ALIVE_IMG }, caption: menu }, { quoted: mek });
    } catch (e) {
        console.error(e);
        reply(`An error occurred: ${e.message}`);
    }
});

cmd({
    pattern: "searchmenu",
    react: "🔍",
    desc: "get cmd list",
    category: "main",
    filename: __filename
}, async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        let menu = '';
        for (let i = 0; i < commands.length; i++) {
            if (commands[i].category === 'search' && !commands[i].dontAddCommandList) {
                menu += `╭━━━〘 🔍 𝕊𝔼𝔸ℝℂℍ 🔍 〙\n┃ ❀ ℂ𝕆𝕄𝕄𝔸ℕ𝔻: ${commands[i].pattern}\n┃ ❀ 𝔻𝔼𝕊ℂ: ${commands[i].desc}\n┃ ❀ 𝕌𝕊𝔸𝔾𝔼: ${commands[i].use}\n╰━━━━━━━━━━━━━━━✦\n\n`;
            }
        }
        await conn.sendMessage(from, { image: { url: config.ALIVE_IMG }, caption: menu }, { quoted: mek });
    } catch (e) {
        console.error(e);
        reply(`An error occurred: ${e.message}`);
    }
});

cmd({
    pattern: "menu",
    desc: "Check commands.",
    category: "main",
    react: "📜",
    filename: __filename
}, async (conn, mek, m, { from, quoted, reply }) => {
    try {
        const menuMessage = `╭───────────❀
│ 🌟 𝕎𝔼𝕃ℂ𝕆𝕄𝔼 𝕋𝕆 𝔻𝕀𝔻𝕌𝕃𝔸 𝕄𝔻 🌟
╰───────────❀
╔══════════✧
║ 👑 𝕆𝕎ℕ𝔼ℝ: 𝔻𝕀𝔻𝕌𝕃𝔸 ℝ𝔸𝕊ℍ𝕄𝕀𝕂𝔸
║ 📞 ℕ𝕌𝕄𝔹𝔼ℝ: +94741820962
║ ⚡ 𝕊ℙ𝔼𝔼𝔻: 000.23
║ 💾 𝕄𝔼𝕄𝕆ℝ𝕐: 64GB
╚══════════✧

    ╭─────────❀
    │ 𝕄𝔼ℕ𝕌 𝕃𝕀𝕊𝕋
    ╰─────────❀

┃ 📜 .𝚖𝚊𝚒𝚗𝚖𝚎𝚗𝚞
┃ 🔍 .𝚜𝚎𝚊𝚛𝚌𝚑𝚖𝚎𝚗𝚞
┃ 👥 .𝚐𝚛𝚘𝚞𝚙𝚖𝚎𝚗𝚞
┃ 👑 .𝚘𝚠𝚗𝚎𝚛𝚖𝚎𝚗𝚞
┃ 📥 .𝚍𝚘𝚠𝚗𝚕𝚘𝚊𝚍𝚖𝚎𝚗𝚞
┃ 🔄 .𝚌𝚘𝚗𝚟𝚎𝚛𝚝𝚖𝚎𝚗𝚞
┃ 🎯 .𝚘𝚝𝚑𝚎𝚛𝚖𝚎𝚗𝚞

╭━━━〘 ℹ️ 𝔹𝕆𝕋 𝕀ℕ𝔽𝕆 〙
┃ 👑 𝕆𝕎ℕ𝔼ℝ: 𝔻𝕀𝔻𝕌𝕃𝔸 ℝ𝔸𝕊ℍ𝕄𝕀𝕂𝔸
┃ 🛠️ 𝔻𝔼𝕍: ℂ𝕐𝔹𝔼ℝ 𝕁𝔸ℕ𝕀𝕐𝔸
┃ 📞 ℂ𝕆ℕ𝕋𝔸ℂ𝕋: +94741820962
╰━━━━━━━━━━━━━━━✦`;

        await conn.sendMessage(from, {
            document: { url: pdfUrl },
            fileName: '🌟 𝔻𝕀𝔻𝕌𝕃𝔸 𝕄𝔻 🌟',
            mimetype: "application/pdf",
            fileLength: 99999999999999,
            pageCount: 2024,
            caption: menuMessage,
            contextInfo: {
                forwardingScore: 999,
                isForwarded: true,
                externalAdReply: {
                    title: '🌟 𝔻𝕀𝔻𝕌𝕃𝔸 𝕄𝔻 𝔹𝕆𝕋 🌟',
                    body: '✨ 𝕐𝕠𝕦𝕣 𝕌𝕝𝕥𝕚𝕞𝕒𝕥𝕖 𝕎𝕙𝕒𝕥𝕤𝔸𝕡𝕡 𝔸𝕤𝕤𝕚𝕤𝕥𝕒𝕟𝕥 ✨',
                    thumbnailUrl: 'https://i.ibb.co/tC37Q7B/20241220-122443.jpg',
                    sourceUrl: 'https://wa.me/94741820962',
                    mediaType: 1,
                    renderLargerThumbnail: true
                }
            }
        });
    } catch (e) {
        console.error(e);
        reply(`${e}`);
    }
});

cmd({
    pattern: "allmenu",
    alias: ["list"],
    react: "📜",
    desc: "Get all commands list.",
    category: "main",
    filename: __filename
}, async (conn, mek, m, { from, quoted, reply }) => {
    try {
        let menu = '';
        for (let i = 0; i < commands.length; i++) {
            if (!commands[i].dontAddCommandList) {
                menu += `╭━━━〘 🌟 𝔻𝕀𝔻𝕌𝕃𝔸 𝕄𝔻 🌟 〙\n┃ ❀ ℂ𝕆𝕄𝕄𝔸ℕ𝔻: ${commands[i].pattern}\n┃ ❀ 𝔻𝔼𝕊ℂ: ${commands[i].desc}\n┃ ❀ 𝕌𝕊𝔸𝔾𝔼: ${commands[i].use}\n╰━━━━━━━━━━━━━━━✦\n\n`;
            }
        }

        let madeMenu = menu || 'No commands available at the moment.';
        await conn.sendMessage(from, { image: { url: config.ALIVE_IMG }, caption: madeMenu }, { quoted: mek });
    } catch (e) {
        console.error(e);
        reply(`An error occurred: ${e.message}`);
    }
});










//   ================== main category plugin====================





//   ======================== song Video =========================

cmd({
    pattern: "video",
    alias: ["ytmp4", "play"],
    react: "🎥",
    desc: "Download Youtube video",
    category: "download",
    use: '.video < Yt url or Name >',
    filename: __filename
}, async (conn, mek, m, { from, prefix, quoted, q, reply }) => {
    try {
        if (!q) return await reply("⚠️ Please provide a YouTube URL or video name!");

        const yt = await ytsearch(q);
        if (yt.results.length < 1) return reply("❌ No results found!");

        let yts = yt.results[0];
        let apiUrl = `https://dark-shan-yt.koyeb.app/download/ytmp4?url=${encodeURIComponent(yts.url)}&quality=3`;
        
        // Fetch the download token
        let response = await fetch(apiUrl);
        let data = await response.json();
        let downloadUrl = data.download;

        let ytmsg = `╭━━━〔 *🌟 DIDULA MD V2 🌟* 〕━━━┈⊷
┃▸╭─────────────────
┃▸┃ 📽️ *VIDEO DOWNLOADER*
┃▸└─────────────────···
╰──────────────────────┈⊷
╭━━❐━⪼
┇📌 *Title:* ${yts.title}
┇⏱️ *Duration:* ${yts.timestamp}
┇👀 *Views:* ${yts.views}
┇👤 *Author:* ${yts.author.name}
┇🔗 *Link:* ${yts.url}
╰━━❑━⪼

*💫 Quality Video Downloader By Didula MD V2*`;

        await conn.sendMessage(from, { image: { url: yts.thumbnail }, caption: ytmsg }, { quoted: mek });
        await conn.sendMessage(from, { video: { url: downloadUrl }, mimetype: "video/mp4" }, { quoted: mek });
        await conn.sendMessage(from, {
            document: { url: downloadUrl },
            mimetype: "video/mp4",
            fileName: `${yts.title}.mp4`,
            caption: `🎥 *${yts.title}*\n\n*🌟 Created By:* Didula Rashmika\n*🤖 Bot:* Didula MD V2`
        }, { quoted: mek });

    } catch (e) {
        console.log(e);
        reply("❌ An error occurred. Please try again later.");
    }
});





cmd({
    pattern: "song",
    alias: ["ytdl3", "yta"],
    react: "🎵",
    desc: "Download Youtube song",
    category: "download",
    use: '.song < Yt url or Name >',
    filename: __filename
}, async (conn, mek, m, { from, prefix, quoted, q, reply }) => {
    try {
        if (!q) return await reply("⚠️ Please provide a YouTube URL or song name!");

        const yt = await ytsearch(q);
        if (yt.results.length < 1) return reply("❌ No results found!");

        let yts = yt.results[0];
        let apiUrl = `https://manul-ofc-ytdl-paid-30a8f429a0a6.herokuapp.com/download/audio?url=${encodeURIComponent(yts.url)}`;
        
        let response = await fetch(apiUrl);
        let data = await response.json();
        
        if (!data.status || !data.downloadUrl) {
            return reply("❌ Failed to fetch download URL");
        }

        let downloadUrl = data.downloadUrl;

        let ytmsg = `╭━━━〔 *🌟 DIDULA MD V2 🌟* 〕━━━┈⊷
┃▸╭─────────────────
┃▸┃ 🎵 *MUSIC DOWNLOADER*
┃▸└─────────────────···
╰──────────────────────┈⊷
╭━━❐━⪼
┇🎧 *Title:* ${yts.title}
┇⏱️ *Duration:* ${yts.timestamp}
┇👀 *Views:* ${yts.views}
┇👤 *Author:* ${yts.author.name}
┇🔗 *Link:* ${yts.url}
╰━━❑━⪼

*💫 High Quality Audio By Didula MD V2*`;

        await conn.sendMessage(from, { image: { url: yts.thumbnail }, caption: ytmsg }, { quoted: mek });
        await conn.sendMessage(from, { audio: { url: downloadUrl }, mimetype: "audio/mpeg" }, { quoted: mek });
        await conn.sendMessage(from, {
            document: { url: downloadUrl },
            mimetype: "audio/mpeg",
            fileName: `${yts.title}.mp3`,
            caption: `🎵 *${yts.title}*\n\n*🌟 Created By:* Didula Rashmika\n*🤖 Bot:* Didula MD V2`
        }, { quoted: mek });

    } catch (e) {
        console.log(e);
        reply("❌ An error occurred. Please try again later.");
    }
});

cmd({ 
    pattern: "songc", 
    alias: ["ytdl3", "yta"], 
    react: "🎵", 
    desc: "Download Youtube song as voice note",
    category: "download", 
    use: '.songc < Yt url or Name >', 
    filename: __filename 
}, async (conn, mek, m, { from, prefix, quoted, q, reply }) => { 
    try { 
        if (!q) return await reply("⚠️ Please provide a YouTube URL or song name!");

        const yt = await ytsearch(q);
        if (yt.results.length < 1) return reply("❌ No results found!");

        let yts = yt.results[0];
        let apiUrl = `https://manul-ofc-ytdl-paid-30a8f429a0a6.herokuapp.com/download/audio?url=${encodeURIComponent(yts.url)}`;
        
        let response = await fetch(apiUrl);
        let data = await response.json();
        
        if (!data.status || !data.downloadUrl) {
            return reply("❌ Failed to fetch download URL");
        }

        let downloadUrl = data.downloadUrl;

        let ytmsg = `╭━━━〔 *🌟 DIDULA MD V2 🌟* 〕━━━┈⊷
┃▸╭─────────────────
┃▸┃ 🎵 *MUSIC DOWNLOADER*
┃▸└─────────────────···
╰──────────────────────┈⊷
╭━━❐━⪼
┇🎧 *Title:* ${yts.title}
┇⏱️ *Duration:* ${yts.timestamp}
┇👀 *Views:* ${yts.views}
┇👤 *Author:* ${yts.author.name}
┇🔗 *Link:* ${yts.url}
╰━━❑━⪼

*💫 High Quality Audio By Didula MD V2*`;

        await conn.sendMessage(from, { image: { url: yts.thumbnail }, caption: ytmsg }, { quoted: mek });
        await conn.sendMessage(from, { audio: { url: downloadUrl }, mimetype: "audio/mpeg", ptt: true }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply("❌ An error occurred. Please try again later.");
    }
});



// ===================== song and video ========================== //









cmd({
    pattern: "heartreact",
    react: "🗣️",
    desc: "",
    category: "",
    use: '.heartreact on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("❌ You are not the owner!");        
if (q == 'on') {
  if ( config.HEART_REACT == 'true') return reply('already on ')
  await input_set('HEART_REACT' , 'true')
  return reply('heartreact turned on')
  }
if ( q == 'off' ) {
   if ( config.HEART_REACT !== 'true') return reply('already off')
  await input_set('HEART_REACT' , 'false')
  return reply('heartreact turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})


cmd({
    pattern: "autovoice",
    react: "🗣️",
    desc: "",
    category: "",
    use: '.autovoice on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("❌ You are not the owner!");        
if (q == 'on') {
  if ( config.AUTO_VOICE == 'true') return reply('already on ')
  await input_set('AUTO_VOICE' , 'true')
  return reply('autovoice turned on')
  }
if ( q == 'off' ) {
   if ( config.AUTO_VOICE !== 'true') return reply('already off')
  await input_set('AUTO_VOICE' , 'false')
  return reply('autovoice turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})


cmd({
    pattern: "autosticker",
    react: "🗣️",
    desc: "",
    category: "",
    use: '.autosticmer on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("❌ You are not the owner!");        
if (q == 'on') {
  if ( config.AUTO_STICKER == 'true') return reply('already on ')
  await input_set('AUTO_STICKER' , 'true')
  return reply('autosticker turned on')
  }
if ( q == 'off' ) {
   if ( config.AUTO_STICKER !== 'true') return reply('already off')
  await input_set('AUTO_STICKER' , 'false')
  return reply('autosticker turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})


cmd({
    pattern: "autobio",
    react: "🗣️",
    desc: "",
    category: "",
    use: '.autobio on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("❌ You are not the owner!");        
if (q == 'on') {
  if ( config.AUTO_BIO == 'true') return reply('already on ')
  await input_set('AUTO_BIO' , 'true')
  return reply('autobio turned on')
  }
if ( q == 'off' ) {
   if ( config.AUTO_BIO !== 'true') return reply('already off')
  await input_set('AUTO_BIO' , 'false')
  return reply('autobio turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})

cmd({
    pattern: "autowelcome",
    react: "🗣️",
    desc: "",
    category: "",
    use: '.autowelcome on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("❌ You are not the owner!");        
if (q == 'on') {
  if ( config.AUTO_WELCOME == 'true') return reply('already on ')
  await input_set('AUTO_WELCOME' , 'true')
  return reply('autowelcome turned on')
  }
if ( q == 'off' ) {
   if ( config.AUTO_WELCOME !== 'true') return reply('already off')
  await input_set('AUTO_WELCOME' , 'false')
  return reply('autowelcome turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})

cmd({
    pattern: "antibot",
    react: "🗣️",
    desc: "",
    category: "",
    use: '.antibot on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("❌ You are not the owner!");        
if (q == 'on') {
  if ( config.ANTI_BOT == 'true') return reply('already on ')
  await input_set('ANTI_BOT' , 'true')
  return reply('antibot turned on')
  }
if ( q == 'off' ) {
   if ( config.ANTI_BOT !== 'true') return reply('already off')
  await input_set('ANTI_BOT' , 'false')
  return reply('antibot turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})

cmd({
    pattern: "antilink",
    react: "🗣️",
    desc: "",
    category: "",
    use: '.antilink on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("❌ You are not the owner!");        
if (q == 'on') {
  if ( config.ANTI_LINK == 'true') return reply('already on ')
  await input_set('ANTI_LINK' , 'true')
  return reply('antilink turned on')
  }
if ( q == 'off' ) {
   if ( config.ANTI_LINK !== 'true') return reply('already off')
  await input_set('ANTI_LINK' , 'false')
  return reply('antilink turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})


cmd({
    pattern: "antibad",
    react: "🗣️",
    desc: "",
    category: "",
    use: '.antibad on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("❌ You are not the owner!");
if (q == 'on') {
  if ( config.ANTI_BAD == 'true') return reply('already on ')
  await input_set('ANTI_BAD' , 'true')
  return reply('antibad turned on')
  }
if ( q == 'off' ) {
   if ( config.ANTI_BAD !== 'true') return reply('already off')
  await input_set('ANTI_BAD' , 'false')
  return reply('antibad turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})        


cmd({
    pattern: "autostatus",
    react: "🗣️",
    desc: "",
    category: "",
    use: '.autostatus on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("❌ You are not the owner!");        
if (q == 'on') {
  if ( config.AUTO_READ_STATUS == 'true') return reply('already on ')
  await input_set('AUTO_READ_STATUS' , 'true')
  return reply('autostatus turned on')
  }
if ( q == 'off' ) {
   if ( config.AUTO_READ_STATUS !== 'true') return reply('already off')
  await input_set('AUTO_READ_STATUS' , 'false')
  return reply('autostatus turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})

cmd({
    pattern: "autotyping",
    react: "🗣️",
    desc: "",
    category: "",
    use: '.autotyping on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("❌ You are not the owner!");        
if (q == 'on') {
  if ( config.AUTO_TYPING == 'true') return reply('already on ')
  await input_set('AUTO_TYPING' , 'true')
  return reply('autotyping turned on')
  }
if ( q == 'off' ) {
   if ( config.AUTO_TYPING !== 'true') return reply('already off')
  await input_set('AUTO_TYPING' , 'false')
  return reply('autotyping turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})        

cmd({
    pattern: "autorecording",
    react: "🗣️",
    desc: "",
    category: "",
    use: '.autorecording on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("❌ You are not the owner!");        
if (q == 'on') {
  if ( config.RECORDING == 'true') return reply('already on ')
  await input_set('RECORDING' , 'true')
  return reply('autorecording turned on')
  }
if ( q == 'off' ) {
   if ( config.RECORDING !== 'true') return reply('already off')
  await input_set('RECORDING' , 'false')
  return reply('autorecording turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})        

cmd({
    pattern: "cmdread",
    react: "🗣️",
    desc: "",
    category: "",
    use: '.autotyping on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("❌ You are not the owner!");        
if (q == 'on') {
  if ( config.READ_CMD == 'true') return reply('already on ')
  await input_set('READ_CMD' , 'true')
  return reply('cmd turned on')
  }
if ( q == 'off' ) {
   if ( config.READ_CMD !== 'true') return reply('already off')
  await input_set('READ_CMD' , 'false')
  return reply('cmdread turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})        

cmd({
    pattern: "autoreact",
    react: "🗣️",
    desc: "",
    category: "",
    use: '.autoreact on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("❌ You are not the owner!");
if (q == 'on') {
  if ( config.AUTO_REACT == 'true') return reply('already on ')
  await input_set('AUTO_REACT' , 'true')
  return reply('autoreact turned on')
  }
if ( q == 'off' ) {
   if ( config.AUTO_REACT !== 'true') return reply('already off')
  await input_set('AUTO_REACT' , 'false')
  return reply('autoreact turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})        



cmd({
    pattern: "alwaysonline",
    react: "🗣️",
    desc: "",
    category: "",
    use: '.alwaysonline on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("❌ You are not the owner!");        
if (q == 'on') {
  if ( config.ALWAYS_ONLINE == 'true') return reply('already on ')
  await input_set('ALWAYS_ONLINE' , 'true')
  return reply('alwaysonline turned on')
  }
if ( q == 'off' ) {
   if ( config.ALWAYS_ONLINE !== 'true') return reply('already off')
  await input_set('ALWAYS_ONLINE' , 'false')
  return reply('alwaysonline turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})        

cmd({
    pattern: "212block",
    react: "🗣️",
    desc: "",
    category: "",
    use: '.212block on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("❌ You are not the owner!");        
if (q == 'on') {
  if ( config.NUMBER_212_BLOCK == 'true') return reply('already on ')
  await input_set('NUMBER_212_BLOCK' , 'true')
  return reply('212block turned on')
  }
if ( q == 'off' ) {
   if ( config.NUMBER_212_BLOCK !== 'true') return reply('already off')
  await input_set('NUMBER_212_BLOCK' , 'false')
  return reply('212block turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})

cmd({
    pattern: "anticall",
    react: "🗣️",
    desc: "",
    category: "",
    use: '.anticall on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("❌ You are not the owner!");        
if (q == 'on') {
  if ( config.ANTI_CALL == 'true') return reply('already on ')
  await input_set('ANTI_CALL' , 'true')
  return reply('anticall turned on')
  }
if ( q == 'off' ) {
   if ( config.ANTI_CALL !== 'true') return reply('already off')
  await input_set('ANTI_CALL' , 'false')
  return reply('anticall turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})

cmd({
    pattern: "antidelete",
    react: "🗣️",
    desc: "",
    category: "",
    use: '.antidelete on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("❌ You are not the owner!");        
if (q == 'on') {
  if ( config.ANTI_DELETE == 'true') return reply('already on ')
  await input_set('ANTI_DELETE' , 'true')
  return reply('antidelete turned on')
  }
if ( q == 'off' ) {
   if ( config.ANTI_DELETE !== 'true') return reply('already off')
  await input_set('ANTI_DELETE' , 'false')
  return reply('antidelete turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})


cmd({
    pattern: "aichat",
    react: "🗣️",
    desc: "",
    category: "",
    use: '.aichat on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("❌ You are not the owner!");        
if (q == 'on') {
  if ( config.AI_CHAT == 'true') return reply('already on ')
  await input_set('AI_CHAT' , 'true')
  return reply('aichat turned on')
  }
if ( q == 'off' ) {
   if ( config.AI_CHAT !== 'true') return reply('already off')
  await input_set('AI_CHAT' , 'false')
  return reply('aichat turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})

cmd({
    pattern: "autosongsend",
    react: "🗣️",
    desc: "",
    category: "",
    use: '.autosongsend on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
    if (!isOwner) return reply("❌ You are not the owner!");        
    if (q == 'on') {
        if (config.AUTO_SONG_SENDER == 'true') return reply('already on');
        await input_set('AUTO_SONG_SENDER', 'true');
        return reply('autosongsend turned on');
    }
    if (q == 'off') {
        if (config.AUTO_SONG_SENDER !== 'true') return reply('already off');
        await input_set('AUTO_SONG_SENDER', 'false');
        return reply('autosongsend turned off');
    }
} catch (e) {
    reply('*Error !!*');
    l(e);
}
});


cmd({
    pattern: "mode",
    react: "🗣️",
    desc: "",
    category: "",
    use: '.mode public/private',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("❌ You are not the owner!");                
if (q == 'private') {
  if ( config.MODE == 'private') return reply('already private ')
  await input_set('MODE' , 'private')
  return reply('private mode turned on')
  }
if ( q == 'public' ) {
   if ( config.MODE !== 'public') return reply('already public')
  await input_set('MODE' , 'public')
  return reply('public mode turned off')
}
if ( q == 'inbox' ) {
   if ( config.MODE !== 'inbox') return reply('already inbox')
  await input_set('MODE' , 'inbox')
  return reply('inbox mode turned off')
}
if ( q == 'groups' ) {
   if ( config.MODE !== 'groups') return reply('already groups')
  await input_set('MODE' , 'groups')
  return reply('groups mode turned off')
}

} catch (e) {
reply('*Error !!*')
l(e)
}
})

cmd({
    pattern: "settings",
    react: "🗣️",
    alias: ["setting"],
    desc: "Check bot online or not.",
    category: "main",
    filename: __filename
}, 
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        if (!isOwner) return;

        const vv = await conn.sendMessage(from, {
            image: { url: 'https://files.catbox.moe/za6ytm.jpg' },
            caption: `*[ •  DIDULA-MD-V2 - SETTINGS‎ • ]*
*╭┈───────────────•*
*┊* *♾️ AUTO_READ_STATUS:* ➠ ${config.AUTO_READ_STATUS}
*┊* *♾️ MODE:* ➠ ${config.MODE} 
*┊* *♾️ AI_CHAT:* ➠ ${config.AI_CHAT} 
*┊* *♾️ ANTI_DELETE:* ➠ ${config.ANTI_DELETE} 
*┊* *♾️ AUTO_VOICE:* ➠ ${config.AUTO_VOICE} 
*┊* *♾️ AUTO_STICKER:* ➠ ${config.AUTO_STICKER} 
*┊* *♾️ ALIVE_IMG:* ➠ ${config.ALIVE_IMG}
*┊* *♾️ ALIVE_MSG:* ➠ ${config.ALIVE_MSG}  
*┊* *♾️ SUDO:* ➠ ${config.SUDO}
*┊* *♾️ ANTI_LINK:* ➠ ${config.ANTI_LINK}
*┊* *♾️ ANTI_CALL:* ➠ ${config.ANTI_CALL} 
*┊* *♾️ ANTI_BAD:* ➠ ${config.ANTI_BAD} 
*┊* *♾️ PREFIX:* ➠ [${config.PREFIX}]
*┊* *♾️ AUTO_RECORDING:* ➠ ${config.RECORDING} 
*┊* *♾️ HEART_REACT:* ➠ ${config.HEART_REACT} 
*┊* *♾️ FOOTER:* ➠ ${config.FOOTER}
*┊* *♾️ AUTO_SONG_SENDER:* ➠ ${config.AUTO_SONG_SENDER} 
*┊* *♾️ CMD_READ:* ➠ ${config.READ_CMD}
*╰┈───────────────•*
┏━━━━━━━━━━━━━━━━━━━━━━━┓
┃      🔗  *CUSTOMIZE YOUR SETTINGS* ⤵️
┗━━━━━━━━━━━━━━━━━━━━━━━┛

┏━━━━━━━━━━━━━━━━━━━━━━━┓
┃       🔧 *OPTIONS MENU* 🔧
┃━━━━━━━━━━━━━━━━━━━━━━━┃

┣━ *_WORK MODE_* ⤵️
┃   ┣ 1.1 🔹 *Public Work*
┃   ┣ 1.2 🔹 *Private Work*
┃   ┣ 1.3 🔹 *Groups Only*
┃   ┗ 1.4 🔹 *Inbox Only*

┣━ *_AUTO VOICE_* ⤵️
┃   ┣ 2.1 🔊 *Auto Voice On*
┃   ┗ 2.2 🔕 *Auto Voice Off*

┣━ *_AUTO STATUS SEEN_* ⤵️
┃   ┣ 3.1 👁️‍🗨️ *Auto Read Status On*
┃   ┗ 3.2 👁️❌ *Auto Read Status Off*

┣━ *_AUTO BIO_* ⤵️
┃   ┣ 4.1 ✍️ *Auto Bio On*
┃   ┗ 4.2 ✍️❌ *Auto Bio Off*

┣━ *_AUTO TYPING_* ⤵️
┃   ┣ 5.1 📝 *Activate Auto Typing*
┃   ┗ 5.2 📝❌ *Deactivate Auto Typing*

┣━ *_AUTO COMMAND READ_* ⤵️
┃   ┣ 6.1 🖊️ *Activate Auto Command Read*
┃   ┗ 6.2 🖊️❌ *Deactivate Auto Command Read*

┣━ *_ANTI CALL_* ⤵️
┃   ┣ 7.1 🔊 *Anti Call On*
┃   ┗ 7.2 🔕 *Anti Call Off*

┣━ *_HEART REACT_* ⤵️
┃   ┣ 8.1 ✍️ *Heart React On*
┃   ┗ 8.2 ✍️❌ *Heart React Off*

┣━ *_ANTI DELETE_* ⤵️
┃   ┣ 9.1 📝 *Activate Anti Delete*
┃   ┗ 9.2 📝❌ *Deactivate Anti Delete*

┣━ *_AUTO STICKER_* ⤵️
┃   ┣ 10.1 👁️‍🗨️ *Auto Sticker On*
┃   ┗ 10.2 👁️❌ *Auto Sticker Off*

┣━ *_AI CHAT* ⤵️
┃   ┣ 11.1 📝 *Activate Ai Chat*
┃   ┗ 11.2 📝❌ *Deactivate Ai Chat*

┣━ *_ANTI LINK_* ⤵️
┃   ┣ 12.1 🖊️ *Activate Anti Link*
┃   ┗ 12.2 🖊️❌ *Deactivate Anti Link*

┣━ *_ANTI BAD_* ⤵️
┃   ┣ 13.1 👁️‍🗨️ *Anti Bad On*
┃   ┗ 13.2 👁️❌ *Anti Bad Off*

┣━ *_AUTO RECORDING_* ⤵️
┃   ┣ 14.1 🔊 *Auto Recording On*
┃   ┗ 14.2 🔕 *Auto Recording Off*

┣━ *_AUTO SONG SENDER_* ⤵️
┃   ┣ 15.1 👁️‍🗨️ *Auto Song Sender On*
┃   ┗ 15.2 👁️❌ *Auto Song Sender Off*
┗━━━━━━━━━━━━━━━━━━━━━━━┛

> *©ᴘᴏᴡᴇʀᴇᴅ ʙʏ DIDULA*
`
        }, { quoted: mek });

        conn.ev.on('messages.upsert', async (msgUpdate) => {
            const msg = msgUpdate.messages[0];
            if (!msg.message || !msg.message.extendedTextMessage) return;

            const selectedOption = msg.message.extendedTextMessage.text.trim();

            if (msg.message.extendedTextMessage.contextInfo && msg.message.extendedTextMessage.contextInfo.stanzaId === vv.key.id) {
                switch (selectedOption) {
                    case '1.1':
                        reply(".mode public" );
                        reply(".restart");
                        break;
                    case '1.2':               
                        reply(".mode private");
                        reply(".restart");
                        break;
                    case '1.3':               
                          reply(".mode groups");
                        reply(".restart");
                      break;
                    case '1.4':     
                        reply(".mode inbox");
                        reply(".restart");
                      break;
                    case '2.1':     
                        reply("autovoice on");
                        reply(".restart");
                        break;
                    case '2.2':     
                        reply(".autovoice off");
                        reply(".restart");
                    break;
                    case '3.1':    
                        reply(".autostatus on");
                        reply(".restart");
                    break;
                    case '3.2':    
                        reply(".autostatus off");
                        reply(".restart");
                    break;
                    case '4.1': 
                    reply(".autobio on");
                    reply(".restart");
                    break;
                    case '4.2': 
                    reply(".autobio off");
                    reply(".restart");
                    break;
                    case '5.1':      
                        reply(".autotyping on");
                        reply(".restart");
                        break;
                    case '5.2':   
                        reply(".autotyping off");
                        reply(".restart");
                    break;
                    case '6.1': 
                        reply(".cmdread on");
                        reply(".restart");
                    break;
                    case '6.2':   
                        reply(".cmdread off");
                        reply(".restart");
                    break;
                    case '7.1': 
                        reply(".anticall on");
                        reply(".restart");
                    break;
                    case '7.2':   
                        reply(".anticall off");
                        reply(".restart");
                        break;
                    case '8.1': 
                        reply(".heartreact on");
                        reply(".restart");
                    break;
                    case '8.2':   
                        reply(".heartreact off");
                        reply(".restart");
                        break;
                    case '9.1': 
                        reply(".antidelete on");
                        reply(".restart");
                    break;
                    case '9.2':   
                        reply(".antidelete off");
                        reply(".restart");
                        break;
                    case '10.1': 
                        reply(".autosticker on");
                        reply(".restart");
                    break;
                    case '10.2':   
                        reply(".autosticker off");
                        reply(".restart");
                        break;
                    case '11.1': 
                        reply(".aichat on");
                        reply(".restart");
                    break;
                    case '11.2':   
                        reply(".aichat off");
                        reply(".restart");
                        break;
                    case '12.1': 
                        reply(".antilink on");
                        reply(".restart");
                    break;
                    case '12.2':   
                        reply(".antilink off");
                        reply(".restart");
                        break;
                    case '13.1': 
                        reply(".antibad on");
                        reply(".restart");
                    break;
                    case '13.2':   
                        reply(".antibad off");
                        reply(".restart");
                        break;
                    case '14.1': 
                        reply(".autorecording on");
                        reply(".restart");
                    break;
                    case '14.2':   
                        reply(".autorecording off");
                        reply(".restart");
                        break;
                    case '15.1': 
                        reply(".autosongsend on");
                        reply(".restart");
                    break;
                    case '15.2':   
                        reply(".autosongsend off");
                        reply(".restart");

                        break;
                    default:
                        reply("Invalid option. Please select a valid option🔴");
                }

            }
        });

    } catch (e) {
        console.error(e);
        await conn.sendMessage(from, { react: { text: '❌', key: mek.key } })
        reply('An error occurred while processing your request.');
    }
});













cmd({
    pattern: "upgrade",
    desc: "Performs complete system upgrade (update → reload → restart)",
    category: "owner",
    filename: __filename,
    react: "⚡"
},
async(conn, mek, m, {from, isOwner, reply}) => {
    try {
        if (!isOwner) return reply("Only bot owners can use this command.");

        // Step 1: Update System Files 
        await m.react('⬇️');
        reply("🔄 Starting system upgrade...\n\n1️⃣ Updating system files...");

        const url = 'https://raw.githubusercontent.com/itsme-didulabot/Didula-MD-DB/main/Didula%20Md%20V2%20-%20System.js';
        const response = await axios.get(url);

        if (response.status !== 200) {
            await m.react('❌');
            return reply('Failed to download update file');
        }

        const pluginPath = path.join(__dirname, '../plugins/system.js');
        fs.writeFileSync(pluginPath, response.data);

        await sleep(1000);
        reply("✅ System files updated successfully\n\n2️⃣ Reloading commands...");

        // Step 2: Reload Commands
        const pluginsDir = path.join(__dirname, '../plugins');
        const files = fs.readdirSync(pluginsDir);

        for (const file of files) {
            if (file.endsWith('.js')) {
                const filePath = path.join(pluginsDir, file);
                delete require.cache[require.resolve(filePath)];
                require(filePath);
                console.log(`Reloaded ${file}`);
            }
        }

        await sleep(1000);
        reply("✅ Commands reloaded successfully\n\n3️⃣ Restarting bot...");

        // Step 3: Restart Bot
        await sleep(1000);
        reply("Didula MD V2 💚 restarting...\n\nPlease wait 1-2 minutes for the bot to come back online.\n\nFollow for updates: https://whatsapp.com/channel/0029VaqqF4GDTkJwKruLSK2f");

        await m.react('✅');
        await sleep(1500);

        // Execute restart using pm2
        require('child_process').exec("pm2 restart all");

    } catch (error) {
        console.error(error);
        await m.react('❌');
        reply('Upgrade failed: ' + error.message);
    }
});


// හුත්තෝ හුත්තෝ හුත්තෝ 🌝ඕක මුලින්ම තියපන් 🌝😂

//  😂මේක තමයි හුත්තෝ main plugin එක 



cmd({
    pattern: "couple",
    desc: "Get random couple photo",
    category: "other",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{


let data = await fetchJson(`https://api.fgmods.xyz/api/img/couple?apikey=nRHt2lt5`)

let boy = `*_Boy_*

> ᴩʀᴏᴊᴇᴄᴛꜱ ᴏꜰ ᴅɪᴅᴜʟᴀ ʀᴀꜱʜᴍɪᴋᴀ`

const fdChannel = {
            newsletterJid: "120363343196447945@newsletter",
            newsletterName: "Didula-MD V2",
            serverMessageId: 999
          };
          const contextMsg = {
            mentionedJid: [m.sender],
            forwardingScore: 999,
            isForwarded: true,
            forwardedNewsletterMessageInfo: fdChannel
          };
          const msgBody = {
            image: {url: `${data.result.boy}`},
            caption: boy,
            contextInfo: contextMsg
          };
         await conn.sendMessage(from, msgBody, {
            'quoted': mek
          })

let girl = `*_Girl_*

> ᴩʀᴏᴊᴇᴄᴛꜱ ᴏꜰ ᴅɪᴅᴜʟᴀ ʀᴀꜱʜᴍɪᴋᴀ`

const fdChannel2 = {
            newsletterJid: "120363343196447945@newsletter",
            newsletterName: "Didula-MD V2",
            serverMessageId: 999
          };
          const contextMsg2 = {
            mentionedJid: [m.sender],
            forwardingScore: 999,
            isForwarded: true,
            forwardedNewsletterMessageInfo: fdChannel2
          };
          const msgBody2 = {
            image: {url: `${data.result.girl}`},
            caption: girl,
            contextInfo: contextMsg2
          };
         await conn.sendMessage(from, msgBody2, {
            'quoted': mek
          })

}catch(e){
console.log(e)
reply(`${e}`)
}
})










// ship command 
const toM = (a) => '@' + a.split('@')[0];
cmd({
    pattern: "ship",
    alias: ["cup", "love"],
    desc: "Randomly pairs the command user with another group member.",
    react: "❤️",
    category: "other",
    filename: __filename,
}, 
async (conn, mek, m, { from, isGroup, groupMetadata, reply }) => {
    try {
        // Ensure command is used in a group
        if (!isGroup) {
            return reply("This command can only be used in groups.");
        }

        // Get group participants
        const participants = groupMetadata.participants.map(p => p.id);

        if (participants.length < 2) {
            return reply("Not enough members to pair.");
        }

        // Sender of the command
        const sender = m.sender;

        // Randomly select another participant
        let randomParticipant;
        do {
            randomParticipant = participants[Math.floor(Math.random() * participants.length)];
        } while (randomParticipant === sender);

        // Pairing message
        const message = `${toM(sender)} ❤️ ${toM(randomParticipant)}\nCongratulations 💖🍻`;

        // Send the message with contextInfo
        await conn.sendMessage(from, {
            text: message,
            contextInfo: {
                mentionedJid: [sender, randomParticipant], // Mention both users
                forwardingScore: 999,
                isForwarded: true,
                forwardedNewsletterMessageInfo: {
                    newsletterJid: '120363343196447945@newsletterr',
                    newsletterName: 'Didula MD',
                    serverMessageId: 143,
                },
            },
        });
    } catch (e) {
        console.error("Error in ship command:", e);
        reply("An error occurred while processing the command. Please try again.");
    }
});
// Insult


// joke 

cmd({
    pattern: "joke",
    desc: "😂 Get a random joke",
    react: "🤣",
    category: "other",
    filename: __filename
},
async (conn, mek, m, { from, q, reply }) => {
    try {
        const url = 'https://official-joke-api.appspot.com/random_joke';  // API for random jokes
        const response = await axios.get(url);
        const joke = response.data;

        const jokeMessage = `
😂 *Here's a random joke for you!* 😂

*${joke.setup}*

${joke.punchline} 😄

> *©Didula MD*`;

        return reply(jokeMessage);
    } catch (e) {
        console.log(e);
        return reply("⚠️ En Error Appears.");
    }
});

// fact

cmd({
    pattern: "fact",
    desc: "🧠 Get a random fun fact",
    react: "🧠",
    category: "other",
    filename: __filename
},
async (conn, mek, m, { from, q, reply }) => {
    try {
        const url = 'https://uselessfacts.jsph.pl/random.json?language=en';  // API for random facts
        const response = await axios.get(url);
        const fact = response.data.text;

        const funFact = `
🧠 *Random Fun Fact* 🧠

${fact}

Isn't that interesting? 😄
`;

        return reply(funFact);
    } catch (e) {
        console.log(e);
        return reply("⚠️ An error occurred while fetching a fun fact. Please try again later.");
    }
});


// fancy 

cmd({
  pattern: "fancy",
  alias: ['font', "style"],
  react: '✍️',
  desc: "Convert text into various fonts.",
  category: "tools",
  filename: __filename
}, async (conn, mek, m, { from, quoted, body, args, q, reply }) => {
  try {
    if (!q) {
      return reply("Please provide text to convert into fonts.");
    }

    let response = await axios.get('https://www.dark-yasiya-api.site/other/font?text=' + encodeURIComponent(q));
    let data = response.data;

    if (!data.status) {
      return reply("Error fetching fonts. Please try again later.");
    }

    let fontResults = data.result.map(font => '*' + font.name + ":*\n" + font.result).join("\n\n");

    // Message formatting
    let message = `*Didula-MD FANCY FONTS*:\n\n${fontResults}\n\n> *BY Didula-MD*`;

    // Sending the message with context info
    await conn.sendMessage(
      from,
      {
        text: message,
        contextInfo: {
          mentionedJid: [m.sender],
          forwardingScore: 999,
          isForwarded: true,
          forwardedNewsletterMessageInfo: {
            newsletterJid: '120363343196447945@newsletterr',
            newsletterName: 'Didula-MD',
            serverMessageId: 143
          }
        }
      },
      { quoted: mek }
    );

  } catch (error) {
    console.error(error);
    reply("An error occurred while fetching fonts.");
  }
});

// pick-up line

cmd({
    pattern: "pickupline",
    alias: ["pickup"],
    desc: "Get a random pickup line from the API.",
    react: "💬",
    category: "other",
    filename: __filename,
}, 
async (conn, mek, m, { from, reply }) => {
    try {
        // Fetch pickup line from the API
        const res = await fetch('https://api.popcat.xyz/pickuplines');

        if (!res.ok) {
            throw new Error(`API request failed with status ${res.status}`);
        }

        const json = await res.json();

        // Log the API response (for debugging purposes)
        console.log('JSON response:', json);

        // Format the pickup line message
        const pickupLine = `*Here's a pickup line for you:*\n\n"${json.pickupline}"\n\n> *© Powered By Didula MD*`;

        // Send the pickup line to the chat
        await conn.sendMessage(from, { text: pickupLine }, { quoted: m });

    } catch (error) {
        console.error("Error in pickupline command:", error);
        reply("Sorry, something went wrong while fetching the pickup line. Please try again later.");
    }
});

// char

cmd({
    pattern: "character",
    alias: ["char"],
    desc: "Check the character of a mentioned user.",
    react: "🔥",
    category: "other",
    filename: __filename,
}, 
async (conn, mek, m, { from, isGroup, text, reply }) => {
    try {
        // Ensure the command is used in a group
        if (!isGroup) {
            return reply("This command can only be used in groups.");
        }

        // Extract the mentioned user
        const mentionedUser = m.message.extendedTextMessage?.contextInfo?.mentionedJid?.[0];
        if (!mentionedUser) {
            return reply("Please mention a user whose character you want to check.");
        }

        // Define character traits
        const userChar = [
            "Sigma",
            "Generous",
            "Grumpy",
            "Overconfident",
            "Obedient",
            "Good",
            "Simp",
            "Kind",
            "Patient",
            "Pervert",
            "Cool",
            "Helpful",
            "Brilliant",
            "Sexy",
            "Hot",
            "Gorgeous",
            "Cute",
        ];

        // Randomly select a character trait
        const userCharacterSelection =
            userChar[Math.floor(Math.random() * userChar.length)];

        // Message to send
        const message = `Character of @${mentionedUser.split("@")[0]} is *${userCharacterSelection}* 🔥⚡`;

        // Send the message with mentions
        await conn.sendMessage(from, {
            text: message,
            mentions: [mentionedUser],
        }, { quoted: m });

    } catch (e) {
        console.error("Error in character command:", e);
        reply("An error occurred while processing the command. Please try again.");
    }
});





cmd({
    pattern: "prefix",
    dontAddCommandList: true,
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{

let gett = await get("PREFIX")
if(gett === q) return await reply("Allready Done")
await input("PREFIX", q)

await reply("*PREFIX updated: " + q + "*")

} catch (e) {
reply('*Error !!*')
l(e)
}
})




cmd({
    pattern: "textsend",
    desc: "text send to jid",
    category: "owner",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{


if(!isOwner) return reply("*_This is an owner cmd._*")
if(!m.quoted) return reply("*_Please reply a text msg._*")
if(!q) return reply("*_Please give me a jid to send this text._*")

await conn.sendMessage(q, { text : m.quoted.msg })

reply("*_Text send successful ✅_*")

}catch(e){
console.log(e)
reply(`${e}`)
}
})












cmd({
    pattern: "fb2",
    desc: "To download facebook videos.",
    category: "download",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{

  if (!args[0]) {
    return reply('*`ρℓєαѕє gινє α ωαιℓ∂ ƒα¢євσσк ℓιηк`*');
  }

  await m.react('🕒');
  let res;
  try {
    res = await igdl(args[0]);
  } catch (error) {
    return reply('*`єяяσя σвтαιηιηg ∂αтα.`*');
  }

  let result = res.data;
  if (!result || result.length === 0) {
    return reply('*`ησ яєѕαℓт ƒσυη∂.`*');
  }

  let data;
  try {
    data = result.find(i => i.resolution === "720p (HD)") || result.find(i => i.resolution === "360p (SD)");
  } catch (error) {
    return reply('*`єяяσя ∂αтα ℓσѕѕ.`*');
  }

  if (!data) {
    return reply('*`ησ ∂αтα ƒσυη∂.`*');
  }

  await m.react('✅');
  let video = data.url;
  let dev = '© 2024 King Hansa FB Downloader | Download with ease, cherish forever.'

  try {
    await conn.sendMessage(m.chat, { video: { url: video }, caption: dev, fileName: 'fb.mp4', mimetype: 'video/mp4' }, { quoted: m });
  } catch (error) {
    return reply('*`єяяσя ∂σωηℓσα∂ νι∂єσ.`*');
  await m.react('❌');
  }
}catch(e){
console.log(e)
  reply(`${e}`)
}
});





cmd({
  pattern: "updatecmd",
  react: "🧞",
  desc: "Update commands.",
  category: "owner",
  filename: __filename
},
async (conn, mek, m, {
  from,
  quoted,
  body,
  isCmd,
  command,
  args,
  q,
  isGroup,
  sender,
  senderNumber,
  botNumber2,
  botNumber,
  pushname,
  isMe,
  isOwner,
  groupMetadata,
  groupName,
  participants,
  groupAdmins,
  isBotAdmins,
  isAdmins,
  reply
}) => {
  try {
    if (!isOwner) return reply("Only bot owners can use this command.");

    const pluginsDir = path.join(__dirname, '../plugins');
    const files = fs.readdirSync(pluginsDir);

    for (const file of files) {
      if (file.endsWith('.js')) {
        const filePath = path.join(pluginsDir, file);
        require(filePath);
        console.log(`Loaded ${file}`);
      }
    }

    reply("Commands updated successfully.💗🌝");
  } catch (e) {
    console.log(e);
    reply(`Error updating commands: ${e.message}`);
  }
});





















cmd({
    pattern: "joinsup",
    react: "🛸",
    alias: ["panel", "support", "request"],
    desc: "join support group ",
    category: "main",
    use: '.joinsup',
    filename: __filename
},

async(conn, mek, m, {from, l, quoted, body, isCmd, umarmd, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
    try {
        const inviteCode = 'H3SknBQ95on6r77Ho9k5VK';
        await conn.groupAcceptInvite(inviteCode);
        reply('Joined successfully!');

    } catch(e) {
        console.log(e);
        reply(`Error: ${e}`);
    }
});







cmd(
  {
    pattern: "gen",
    alias: ["genboy", "genimg"],
    desc: "Generate AI profile picture",
    category: "convert",
    react: "🖼️",
    filename: __filename,
  },
  async (conn, mek, m, { from, args, reply }) => {
    try {
      let prompt = args.join(" ");
      if (!prompt) return reply("⚠️ Please provide a prompt! (Example: `.genpfp Red flowers`)");

      let apiUrl = `https://manul-ofc-tech-api-1e5585f5ebef.herokuapp.com/fluxai?prompt=${encodeURIComponent(prompt)}`;
      let response = await axios.get(apiUrl, { responseType: "arraybuffer" });

      await conn.sendMessage(
        from,
        { image: response.data, caption: `🎨 *AI Generated Image for:* _${prompt}_` },
        { quoted: m }
      );

    } catch (e) {
      console.error("GenPFP Command Error:", e);
      reply(`❌ Error: ${e.message}`);
    }
  }
);






cmd({
    pattern: "alive2",
    react: "💝",
    desc: "Check bot status",
    category: "main",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
  async function createImage(url) {
    const { imageMessage } = await generateWAMessageContent({
      image: {
        url: "https://files.catbox.moe/za6ytm.jpg"
      }
    }, {
      upload: conn.waUploadToServer
    });
    return imageMessage;
  }

  let push = [{
    body: proto.Message.InteractiveMessage.Body.fromObject({
      text: `✨ Bot is Online!`
    }),
    footer: proto.Message.InteractiveMessage.Footer.fromObject({
      text: config.FOOTER
    }),
    header: proto.Message.InteractiveMessage.Header.fromObject({
      title: 'Hello ' + pushname,
      hasMediaAttachment: true,
      imageMessage: await createImage()
    }),
    nativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.fromObject({
      buttons: [{
        "name": "quick_reply",
        "buttonParamsJson": "{\"display_text\":\"Menu\",\"id\":\".menu\"}"
      }]
    })
  }];

  const msg = generateWAMessageFromContent(m.chat, {
    viewOnceMessage: {
      message: {
        messageContextInfo: {
          deviceListMetadata: {},
          deviceListMetadataVersion: 2
        },
        interactiveMessage: proto.Message.InteractiveMessage.fromObject({
          body: proto.Message.InteractiveMessage.Body.create({
            text: '🌟 Bot Status Check'
          }),
          footer: proto.Message.InteractiveMessage.Footer.create({
            text: config.FOOTER
          }),
          header: proto.Message.InteractiveMessage.Header.create({
            hasMediaAttachment: false
          }),
          carouselMessage: proto.Message.InteractiveMessage.CarouselMessage.fromObject({
            cards: [...push]
          })
        })
      }
    }
  }, {});

  await conn.relayMessage(m.chat, msg.message, {
    messageId: msg.key.id
  });

}catch(e){
console.log(e)
reply(`${e}`)
}
})












cmd({
    pattern: "pin",
    react: "😌",
    desc: "downlod images",
    category: "downlod",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
  if (!q) return reply(`Please give me song name ?`);
  async function createImage(url) {
    const { imageMessage } = await generateWAMessageContent({
      image: {
        url
      }
    }, {
      upload: conn.waUploadToServer
    });
    return imageMessage;
  }

  function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
  }
  let push = [];
  let { data } = await axios.get(`https://allstars-apis.vercel.app/pinterest?search=${q}`);
  let res = data.data.map(v => v);
  shuffleArray(res); // Mengacak array
  let ult = res.splice(0, 10); // Mengambil 10 gambar pertama dari array yang sudah diacak
  let i = 1;
  for (let pus of ult) {
    push.push({
      body: proto.Message.InteractiveMessage.Body.fromObject({
        text: `Images - ${i++}`
      }),
      footer: proto.Message.InteractiveMessage.Footer.fromObject({
        text: config.FOOTER
      }),
      header: proto.Message.InteractiveMessage.Header.fromObject({
        title: 'Hello ' + pushname,
        hasMediaAttachment: true,
        imageMessage: await createImage(pus)
      }),
      nativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.fromObject({
            buttons: [
              {
                "name": "single_select",
                "buttonParamsJson": "{\"title\":\"title\",\"sections\":[{\"title\":\"title\",\"highlight_label\":\"label\",\"rows\":[{\"header\":\"header\",\"title\":\"title\",\"description\":\"description\",\"id\":\"id\"},{\"header\":\"header\",\"title\":\"title\",\"description\":\"description\",\"id\":\"id\"}]}]}"
              },
              {
                "name": "quick_reply",
                "buttonParamsJson": "{\"display_text\":\"quick_reply\",\"id\":\"message\"}"
              },
              {
                 "name": "cta_url",
                 "buttonParamsJson": "{\"display_text\":\"url\",\"url\":\"https://www.google.com\",\"merchant_url\":\"https://www.google.com\"}"
              },
              {
                 "name": "cta_call",
                 "buttonParamsJson": "{\"display_text\":\"call\",\"id\":\"message\"}"
              },
              {
                 "name": "cta_copy",
                 "buttonParamsJson": "{\"display_text\":\"copy\",\"id\":\"123456789\",\"copy_code\":\"message\"}"
              },
              {
                 "name": "cta_reminder",
                 "buttonParamsJson": "{\"display_text\":\"cta_reminder\",\"id\":\"message\"}"
              },
              {
                 "name": "cta_cancel_reminder",
                 "buttonParamsJson": "{\"display_text\":\"cta_cancel_reminder\",\"id\":\"message\"}"
              },
              {
                 "name": "address_message",
                 "buttonParamsJson": "{\"display_text\":\"address_message\",\"id\":\"message\"}"
              },
              {
                 "name": "send_location",
                 "buttonParamsJson": ""
              }
           ]
      })
    });
  }
  const msg = generateWAMessageFromContent(m.chat, {
    viewOnceMessage: {
      message: {
        messageContextInfo: {
          deviceListMetadata: {},
          deviceListMetadataVersion: 2
        },
        interactiveMessage: proto.Message.InteractiveMessage.fromObject({
          body: proto.Message.InteractiveMessage.Body.create({
            text: 'Hellow how are you baby !'
          }),
          footer: proto.Message.InteractiveMessage.Footer.create({
            text: config.FOOTER
          }),
          header: proto.Message.InteractiveMessage.Header.create({
            hasMediaAttachment: false
          }),
          carouselMessage: proto.Message.InteractiveMessage.CarouselMessage.fromObject({
            cards: [
              ...push
            ]
          })
        })
      }
    }
  }, {});
  await conn.relayMessage(m.chat, msg.message, {
    messageId: msg.key.id
  });

}catch(e){
console.log(e)
reply(`${e}`)
}
})



















cmd({
  on: "body"
},
async (conn,mek, m, { from, body, isGroup, isAdmins, isBotAdmins, reply, sender }) => {
    try {

        const badWords = ["wtf", "mia","පොන්නයා","හැමිනෙනවා","කැරියා", "හුත්තා", "හුත්තා","පකයා","fuck","sex","huththa","pakaya","ponnaya","hutto","kariya","pakaya","hukapan","hukanna","hutto","xvdl","hutto","Hukapamm","lol"]
        if (!isGroup || isAdmins || !isBotAdmins) return; 

        const lowerCaseMessage = body.toLowerCase();
        const containsBadWord = badWords.some(word => lowerCaseMessage.includes(word));

        if (containsBadWord & config.ANTI_BAD === 'true') {
          await conn.sendMessage(from, { delete: mek.key }, { quoted: mek });
          await conn.sendMessage(from, { text: "⚠️BAD WORDS NOT ALLOWED⚠️ " }, { quoted: mek });
          await conn.groupParticipantsUpdate(from, [sender], 'remove');
        }
    } catch (error) {
        console.error(error)
        reply("An error occurred while processing the message.")
    }
})
const linkPatterns = [
    /https?:\/\/(?:chat\.whatsapp\.com|wa\.me)\/\S+/gi,   
    /https?:\/\/(?:t\.me|telegram\.me)\/\S+/gi,           
    /https?:\/\/(?:www\.)?linkedin\.com\/\S+/gi,         
    /https?:\/\/(?:www\.)?snapchat\.com\/\S+/gi,         
    /https?:\/\/(?:www\.)?pinterest\.com\/\S+/gi,         
    /https?:\/\/(?:www\.)?reddit\.com\/\S+/gi,            
    /https?:\/\/ngl\/\S+/gi,                             
    /https?:\/\/(?:www\.)?discord\.com\/\S+/gi,           
    /https?:\/\/(?:www\.)?twitch\.tv\/\S+/gi,             
    /https?:\/\/(?:www\.)?vimeo\.com\/\S+/gi,            
    /https?:\/\/(?:www\.)?dailymotion\.com\/\S+/gi,      
    /https?:\/\/(?:www\.)?medium\.com\/\S+/gi,

];

cmd({
    on: "body"
}, async (conn, mek, m, { from, body, sender, isGroup, isAdmins, isBotAdmins, reply }) => {
    try {
        if (!isGroup || isAdmins || !isBotAdmins) return; // Skip if not in group, or sender is admin, or bot is not admin

        const containsLink = linkPatterns.some(pattern => pattern.test(body));

        if (containsLink && config.ANTI_LINK === 'true') {
            // Delete the message
            await conn.sendMessage(from, { delete: mek.key }, { quoted: mek });

            // Warn the user
            await conn.sendMessage(from, { text: `⚠️ Links are not allowed in this group.\n@${sender.split('@')[0]} has been removed. 🚫`, mentions: [sender] }, { quoted: mek });

             // Remove the user from the group
            await conn.groupParticipantsUpdate(from, [sender], 'remove');
        }
    } catch (error) {
        console.error(error);
        reply("An error occurred while processing the message.");
    }
});








cmd({ 
    pattern: "movie", 
    alias: ["film", "cinema"], 
    react: "🎬", 
    desc: "Search and Download Movies with Sinhala Subtitles", 
    category: "download", 
    use: '.movie < Movie Name >', 
    filename: __filename 
}, async (conn, mek, m, { from, prefix, quoted, q, reply }) => { 
    try { 
        if (!q) return await reply("⚠️ Please provide a movie name!");

        // Search for the movie
        let searchUrl = `https://omindu-api.up.railway.app/api/sinhalasub/search?query=${encodeURIComponent(q)}`;
        let searchResponse = await fetch(searchUrl);
        let searchData = await searchResponse.json();

        if (!searchData.results.movies || searchData.results.movies.length < 1) 
            return reply("❌ No movies found!");

        let movie = searchData.results.movies[0];

        // Get download links
        let downloadUrl = `https://omindu-api.up.railway.app/api/sinhalasub/download?url=${encodeURIComponent(movie.link)}`;
        let downloadResponse = await fetch(downloadUrl);
        let downloadData = await downloadResponse.json();

        let movieInfo = downloadData.info;
        let dlLinks = downloadData.dl_links;

        let movieMsg = `╭━━━〔 *🌟 DIDULA MD V2 🌟* 〕━━━┈⊷
┃▸╭─────────────────
┃▸┃ 🎬 *MOVIE DOWNLOADER*
┃▸└─────────────────···
╰──────────────────────┈⊷
╭━━❐━⪼
┇📌 *Title:* ${movieInfo.title}
┇📅 *Release Date:* ${movieInfo.release_date}
┇⏱️ *Runtime:* ${movieInfo.runtime}
┇⭐ *TMDB Rating:* ${movieInfo.tmdb_Rating}
┇🎭 *Genres:* ${movieInfo.genres.join(", ")}
┇🎬 *Director:* ${movieInfo.director.name}
╰━━❑━⪼

📥 *Download Links:*

*Server 1:*
${dlLinks.server_01.map(link => `▢ ${link.quality} (${link.size})\n${link.link}`).join('\n\n')}

*Telegram:*
${dlLinks.telagram.map(link => `▢ ${link.quality} (${link.size})\n${link.link}`).join('\n\n')}

*Server 2:*
${dlLinks.server_02.map(link => `▢ ${link.quality} (${link.size})\n${link.link}`).join('\n\n')}

*Server 3:*
${dlLinks.server_03.map(link => `▢ ${link.quality} (${link.size})\n${link.link}`).join('\n\n')}

*Type . dl <download link> for download movie 💗😚*

*💫 Quality Movie Downloader By Didula MD V2*`;

        await conn.sendMessage(from, { 
            image: { url: movieInfo.poster }, 
            caption: movieMsg 
        }, { quoted: mek });

    } catch (e) {
        console.log(e);
        reply("❌ An error occurred. Please try again later.");
    }
});


cmd({
    pattern: "itnnews",
    desc: "Get the latest ITN news headlines or details of a given link.",
    category: "news",
    react: "📰",
    filename: __filename
},
async (conn, mek, m, { from, reply, q }) => {
    try {
        const rssFeedUrl = 'https://www.itnnews.lk/feed/';
        const response = await axios.get(rssFeedUrl);
        const xmlData = response.data;

        const parser = new xml2js.Parser();
        const result = await parser.parseStringPromise(xmlData);

        const newsItems = result.rss.channel[0].item.map(item => ({
            title: item.title[0],
            link: item.link[0],
            description: item.description[0],
            pubDate: item.pubDate[0]
        }));

        // User එකට link එකක් දීලා search කරොත්
        if (q && q.startsWith("https://www.itnnews.lk/")) {
            const article = newsItems.find(news => news.link === q.trim());
            if (!article) return reply("❌ Sorry, this news article was not found in the latest updates!");

            let articleText = `*Didula MD V2 - 📰 ITN News Details:*\n\n`;
            articleText += `📌 *${article.title}*\n`;
            articleText += `📅 _${article.pubDate}_\n`;
            articleText += `📖 ${article.description}\n`;
            articleText += `🔗 ${article.link}\n\n> ᴩʀᴏᴊᴇᴄᴛꜱ ᴏꜰ ᴅɪᴅᴜʟᴀ ʀᴀꜱʜᴍɪᴋᴀ`;

            return reply(articleText);
        }

        // User එක link එකක් දීලා නැත්නම් Latest 5 news return කරනවා
        let newsText = `*📰 ITN Latest News:*\n\n`;
        newsItems.slice(0, 5).forEach((news, index) => {
            newsText += `📌 *${index + 1}.* *${news.title}*\n`;
            newsText += `📅 _${news.pubDate}_\n`;
            newsText += `🔗 ${news.link}\n\n\n> ᴩʀᴏᴊᴇᴄᴛꜱ ᴏꜰ ᴅɪᴅᴜʟᴀ ʀᴀꜱʜᴍɪᴋᴀ`;
        });

        reply(newsText);
    } catch (error) {
        console.error("Error fetching ITN News:", error);
        reply("❌ Could not fetch ITN news. Please try again later.");
    }
});














cmd({
    pattern: "pornhub",
    alias: ["ph"],
    react: "🎥",
    desc: "download xVideo",
    category: "download",
    filename: __filename
},
async(conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        if (!q) return reply("*⚠️ Please provide a video title or URL*\n\n*Example:* .xvideo Nicolette");

        const query = String(q);
        const searchResponse = await axios.get(`https://ipa-oya.vercel.app/api/ph?q=${encodeURIComponent(query)}`);

        const deta = searchResponse.data;
        const videoUrl = deta.url;

        let desc = `🎥 *Didula MD V2 - Now Downloading:* ${deta.title}

⏳ *Please wait, processing your request...*`;

        await conn.sendMessage(from, { 
            image: { url: deta.image }, 
            caption: desc 
        }, { quoted: mek }).catch(() => reply("❌ Error sending thumbnail"));

        try {
            const downloadResponse = await axios.get(`https://ipa-oya.vercel.app/api/phdl?q=${encodeURIComponent(videoUrl)}`);
            const downloadUrls = downloadResponse.data;

            if (!downloadUrls || downloadUrls.length === 0) {
                return reply("❌ No download links found.");
            }

            let downloadMessage = "🎥 *Didula MD V2 Successfully Downloaded!*\n\nAvailable Resolutions:\n";
            downloadUrls.forEach((video) => {
                downloadMessage += `- ${video.resolution}p: ${video.download_url}\n`;
            });

            // Send the first download link as a video message
            const firstDownloadUrl = downloadUrls[0].download_url;
            await conn.sendMessage(from, { 
                video: { url: firstDownloadUrl }, 
                caption: downloadMessage 
            }, { quoted: mek });

        } catch (error) {
            reply("❌ Error fetching download links: " + error.message);
        }

    } catch (e) {
        console.log(e);
        reply(`❌ Error: ${e.message}`);
    }
});


cmd({
    pattern: "xvideo",
    alias: ["xvideo2"],
    react: "🎥",
    desc: "download",
    category: "download",
    filename: __filename
},
async(conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        if (!q) return reply("*⚠️ Please provide a video title or URL*\n\n*Example:* .xvideo My MILF Secretary Love");

        const query = String(q);
        const searchResponse = await axios.get(`https://api.giftedtech.my.id/api/search/xvideossearch?apikey=gifted&query=${encodeURIComponent(query)}`);

        if (!searchResponse.data.results || !searchResponse.data.results.length) {
            return reply("❌ No results found! Please try another search.");
        }

        const deta = searchResponse.data.results[0];
        const videoUrl = deta.url;

        let desc = `🎥 *Didula MD V2 - Now Downloading:* ${deta.title}

⏱️ *Duration:* ${deta.duration}
👁️ *Views:* ${deta.views || 'N/A'}
📅 *Quality:* ${deta.quality || 'N/A'}

⏳ *Please wait, processing your request...*`;

        await conn.sendMessage(from, { 
            image: { url: deta.thumb }, 
            caption: desc 
        }, { quoted: mek }).catch(() => reply("❌ Error sending thumbnail"));

        try {
            const downloadResponse = await axios.get(`https://api.giftedtech.my.id/api/download/xvideosdl?apikey=gifted&url=${encodeURIComponent(videoUrl)}`);

            const downloadUrl = downloadResponse.data.result.download_url;

            await conn.sendMessage(from, { 
                video: { url: downloadUrl }, 
                mimetype: "video/mp4", 
                caption: "🎥 *Didula MD V2 Successfully Downloaded!*" 
            }, { quoted: mek });

        } catch (error) {
            reply("❌ Error downloading video: " + error.message);
        }

    } catch (e) {
        console.log(e);
        reply(`❌ Error: ${e.message}`);
    }
});




cmd({
    pattern: "hirucheck",
    alias: ["hirunews","newshiru","hirulk"],
    react: "⭐",
    category: "search",
    desc: "Fetch the latest news from the SUHAS API in Hiru API.",
    use: "",
    filename: __filename,
},
    async (conn, mek, m, {
        from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber,
        botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName,
        participants, groupAdmins, isBotAdmins, isAdmins, reply
    }) => {
        try {
            const apiUrl = `https://suhas-bro-apii.vercel.app/hiru`;
//Dont Change This API Key
            const response = await axios.get(apiUrl);
            const data = response.data;

            if (!data || !data.newsURL || !data.title || !data.image || !data.text) {
                return reply(`*No News Available At This Moment* ❗`);
            }

            const { newsURL, title, image, text, Power } = data;

            let newsInfo = "𝐃𝐢𝐝𝐮𝐥𝐚 𝐌𝐃 𝐕𝟐 𝐍𝐞𝐰𝐬 📰\n\n";
            newsInfo += `✨ *Title*: ${title}\n\n`;
            newsInfo += `📑 *Description*:\n${text}\n\n`;
            newsInfo += `⛓️‍💥 *Url*: www.hirunews.lk\n\n`;
            newsInfo += `> *ᴩʀᴏᴊᴇᴄᴛꜱ ᴏꜰ ᴅɪᴅᴜʟᴀ ʀᴀꜱʜᴍɪᴋᴀ*`;

            if (image) {
                await conn.sendMessage(m.chat, {
                    image: { url: image },
                    caption: newsInfo,
                }, { quoted: m });
            } else {
                await conn.sendMessage(m.chat, { text: newsInfo }, { quoted: m });
            }

        } catch (error) {
            console.error(error);
            reply(`*An Error Occurred While Fetching News At This Moment* ❗`);
        }
    }
);






cmd({
    pattern: "happy",
    desc: "Displays a dynamic edit msg for fun.",
    category: "other",
    react: "😂",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const loadingMessage = await conn.sendMessage(from, { text: '😂' });
        const emojiMessages = [
            "😃", "😄", "😁", "😊", "😎", "🥳",
            "😸", "😹", "🌞", "🌈", "😃", "😄",
            "😁", "😊", "😎", "🥳", "😸", "😹",
            "🌞", "🌈", "😃", "😄", "😁", "😊"
        ];

        for (const line of emojiMessages) {
            await new Promise(resolve => setTimeout(resolve, 1000)); // Delay for 1 second
            await conn.relayMessage(
                from,
                {
                    protocolMessage: {
                        key: loadingMessage.key,
                        type: 14,
                        editedMessage: {
                            conversation: line,
                        },
                    },
                },
                {}
            );
        }
    } catch (e) {
        console.log(e);
        reply(`❌ *Error!* ${e.message}`);
    }
});

cmd({
    pattern: "heart",
    desc: "Displays a dynamic edit msg for fun.",
    category: "other",
    react: "❤️",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const loadingMessage = await conn.sendMessage(from, { text: '🖤' });
        const emojiMessages = [
            "💖", "💗", "💕", "🩷", "💛", "💚",
            "🩵", "💙", "💜", "🖤", "🩶", "🤍",
            "🤎", "❤️‍🔥", "💞", "💓", "💘", "💝",
            "♥️", "💟", "❤️‍🩹", "❤️"
        ];

        for (const line of emojiMessages) {
            await new Promise(resolve => setTimeout(resolve, 1000)); // Delay for 1 second
            await conn.relayMessage(
                from,
                {
                    protocolMessage: {
                        key: loadingMessage.key,
                        type: 14,
                        editedMessage: {
                            conversation: line,
                        },
                    },
                },
                {}
            );
        }
    } catch (e) {
        console.log(e);
        reply(`❌ *Error!* ${e.message}`);
    }
});

cmd({
    pattern: "angry",
    desc: "Displays a dynamic edit msg for fun.",
    category: "other",
    react: "🤡",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const loadingMessage = await conn.sendMessage(from, { text: '👽' });
        const emojiMessages = [
            "😡", "😠", "🤬", "😤", "😾", "😡",
            "😠", "🤬", "😤", "😾"
        ];

        for (const line of emojiMessages) {
            await new Promise(resolve => setTimeout(resolve, 1000)); // Delay for 1 second
            await conn.relayMessage(
                from,
                {
                    protocolMessage: {
                        key: loadingMessage.key,
                        type: 14,
                        editedMessage: {
                            conversation: line,
                        },
                    },
                },
                {}
            );
        }
    } catch (e) {
        console.log(e);
        reply(`❌ *Error!* ${e.message}`);
    }
});

cmd({
    pattern: "sad",
    desc: "Displays a dynamic edit msg for fun.",
    category: "other",
    react: "😶",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const loadingMessage = await conn.sendMessage(from, { text: '😔' });
        const emojiMessages = [
            "🥺", "😟", "😕", "😖", "😫", "🙁",
            "😩", "😥", "😓", "😪", "😢", "😔",
            "😞", "😭", "💔", "😭", "😿"
        ];

        for (const line of emojiMessages) {
            await new Promise(resolve => setTimeout(resolve, 1000)); // Delay for 1 second
            await conn.relayMessage(
                from,
                {
                    protocolMessage: {
                        key: loadingMessage.key,
                        type: 14,
                        editedMessage: {
                            conversation: line,
                        },
                    },
                },
                {}
            );
        }
    } catch (e) {
        console.log(e);
        reply(`❌ *Error!* ${e.message}`);
    }
});

cmd({
    pattern: "shy",
    desc: "Displays a dynamic edit msg for fun.",
    category: "tools",
    react: "🧐",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const loadingMessage = await conn.sendMessage(from, { text: '🧐' });
        const emojiMessages = [
            "😳", "😊", "😶", "🙈", "🙊",
            "😳", "😊", "😶", "🙈", "🙊"
        ];

        for (const line of emojiMessages) {
            await new Promise(resolve => setTimeout(resolve, 1000)); // Delay for 1 second
            await conn.relayMessage(
                from,
                {
                    protocolMessage: {
                        key: loadingMessage.key,
                        type: 14,
                        editedMessage: {
                            conversation: line,
                        },
                    },
                },
                {}
            );
        }
    } catch (e) {
        console.log(e);
        reply(`❌ *Error!* ${e.message}`);
    }
});

cmd({
    pattern: "moon",
    desc: "Displays a dynamic edit msg for fun.",
    category: "tools",
    react: "🌚",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const loadingMessage = await conn.sendMessage(from, { text: '🌝' });
        const emojiMessages = [
            "🌗", "🌘", "🌑", "🌒", "🌓", "🌔",
            "🌕", "🌖", "🌗", "🌘", "🌑", "🌒",
            "🌓", "🌔", "🌕", "🌖", "🌗", "🌘",
            "🌑", "🌒", "🌓", "🌔", "🌕", "🌖",
            "🌗", "🌘", "🌑", "🌒", "🌓", "🌔",
            "🌕", "🌖", "🌝🌚"
        ];

        for (const line of emojiMessages) {
            await new Promise(resolve => setTimeout(resolve, 1000)); // Delay for 1 second
            await conn.relayMessage(
                from,
                {
                    protocolMessage: {
                        key: loadingMessage.key,
                        type: 14,
                        editedMessage: {
                            conversation: line,
                        },
                    },
                },
                {}
            );
        }
    } catch (e) {
        console.log(e);
        reply(`❌ *Error!* ${e.message}`);
    }
});

cmd({
    pattern: "confused",
    desc: "Displays a dynamic edit msg for fun.",
    category: "tools",
    react: "🤔",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const loadingMessage = await conn.sendMessage(from, { text: '🤔' });
        const emojiMessages = [
            "😕", "😟", "😵", "🤔", "😖", 
            "😲", "😦", "🤷", "🤷‍♂️", "🤷‍♀️"
        ];

        for (const line of emojiMessages) {
            await new Promise(resolve => setTimeout(resolve, 1000)); // Delay for 1 second
            await conn.relayMessage(
                from,
                {
                    protocolMessage: {
                        key: loadingMessage.key,
                        type: 14,
                        editedMessage: {
                            conversation: line,
                        },
                    },
                },
                {}
            );
        }
    } catch (e) {
        console.log(e);
        reply(`❌ *Error!* ${e.message}`);
    }
});

cmd({
    pattern: "hot",
    desc: "Displays a dynamic edit msg for fun.",
    category: "tools",
    react: "💋",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const loadingMessage = await conn.sendMessage(from, { text: '💋' });
        const emojiMessages = [
            "🥵", "❤️", "💋", "😫", "🤤", 
            "😋", "🥵", "🥶", "🙊", "😻", 
            "🙈", "💋", "🫂", "🫀", "👅", 
            "👄", "💋"
        ];

        for (const line of emojiMessages) {
            await new Promise(resolve => setTimeout(resolve, 1000)); // Delay for 1 second
            await conn.relayMessage(
                from,
                {
                    protocolMessage: {
                        key: loadingMessage.key,
                        type: 14,
                        editedMessage: {
                            conversation: line,
                        },
                    },
                },
                {}
            );
        }
    } catch (e) {
        console.log(e);
        reply(`❌ *Error!* ${e.message}`);
    }
});

cmd({
    pattern: "didula",
    desc: "Displays a dynamic edit msg for fun.",
    category: "tools",
    react: "🗿",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const loadingMessage = await conn.sendMessage(from, { text: 'Didula-AI🗿' });

        // Define the ASCII art messages
        const asciiMessages = [
            "⠀⠀⠀⣠⣶⡾⠏⠉⠙⠳⢦⡀⠀⠀⠀⢠⠞⠉⠙⠲⡀⠀\n ⠀⣴⠿⠏⠀⠀⠀⠀⠀     ⢳⡀⠀⡏⠀⠀⠀   ⠀  ⢷\n⢠⣟⣋⡀⢀⣀⣀⡀⠀⣀⡀   ⣧⠀⢸⠀⠀⠀  ⠀    ⡇\n⢸⣯⡭⠁⠸⣛⣟⠆⡴⣻⡲     ⣿  ⣸   Nikal   ⡇\n ⣟⣿⡭⠀⠀⠀⠀⠀⢱⠀⠀      ⣿  ⢹⠀          ⡇\n  ⠙⢿⣯⠄⠀⠀⠀__⠀   ⠀   ⡿ ⠀⡇⠀⠀⠀⠀    ⡼\n⠀⠀⠀⠹⣶⠆⠀⠀⠀⠀⠀⡴⠃⠀   ⠘⠤⣄⣠⠞⠀\n⠀⠀⠀⠀⢸⣷⡦⢤⡤⢤⣞⣁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⢀⣤⣴⣿⣏⠁⠀⠀⠸⣏⢯⣷⣖⣦⡀⠀⠀⠀⠀⠀⠀\n⢀⣾⣽⣿⣿⣿⣿⠛⢲⣶⣾⢉⡷⣿⣿⠵⣿⠀⠀⠀⠀⠀⠀\n⣼⣿⠍⠉⣿⡭⠉⠙⢺⣇⣼⡏⠀⠀ ⠀⣄⢸⠀⠀⠀⠀⠀⠀`", "⠀⠀⠀⣠⣶⡾⠏⠉⠙⠳⢦⡀⠀⠀⠀⢠⠞⠉⠙⠲⡀⠀\n ⠀⣴⠿⠏⠀⠀⠀⠀⠀  ⠀  ⢳⡀⠀⡏⠀⠀⠀   ⠀  ⢷\n⢠⣟⣋⡀⢀⣀⣀⡀⠀⣀⡀   ⣧⠀⢸⠀⠀⠀       ⡇\n⢸⣯⡭⠁⠸⣛⣟⠆⡴⣻⡲     ⣿  ⣸   Lavde   ⡇\n ⣟⣿⡭⠀⠀⠀⠀⠀⢱⠀⠀      ⣿  ⢹⠀          ⡇\n  ⠙⢿⣯⠄⠀⠀|__|⠀⠀   ⡿ ⠀⡇⠀⠀⠀⠀    ⡼\n⠀⠀⠀⠹⣶⠆⠀⠀⠀⠀⠀⡴⠃⠀   ⠘⠤⣄⣠⠞⠀\n⠀⠀⠀⠀⢸⣷⡦⢤⡤⢤⣞⣁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⢀⣤⣴⣿⣏⠁⠀⠀⠸⣏⢯⣷⣖⣦⡀⠀⠀⠀⠀⠀⠀\n⢀⣾⣽⣿⣿⣿⣿⠛⢲⣶⣾⢉⡷⣿⣿⠵⣿⠀⠀⠀⠀⠀⠀\n⣼⣿⠍⠉⣿⡭⠉⠙⢺⣇⣼⡏⠀⠀ ⠀⣄⢸⠀⠀⠀⠀⠀⠀`", "⠀⠀⠀⣠⣶⡾⠏⠉⠙⠳⢦⡀⠀⠀⠀⢠⠞⠉⠙⠲⡀⠀\n ⠀⣴⠿⠏⠀⠀     ⠀   ⢳⡀⠀⡏⠀⠀    ⠀  ⢷\n⢠⣟⣋⡀⢀⣀⣀⡀⠀⣀⡀   ⣧⠀⢸⠀⠀⠀⠀      ⡇\n⢸⣯⡭⠁⠸⣛⣟⠆⡴⣻⡲    ⣿  ⣸   Pehli   ⡇\n ⣟⣿⡭⠀⠀⠀⠀⠀⢱⠀⠀     ⣿  ⢹⠀           ⡇\n  ⠙⢿⣯⠄⠀⠀(P)⠀⠀     ⡿ ⠀⡇⠀⠀⠀⠀    ⡼\n⠀⠀⠀⠹⣶⠆⠀⠀⠀⠀⠀⡴⠃⠀   ⠘⠤⣄⣠⠞⠀\n⠀⠀⠀⠀⢸⣷⡦⢤⡤⢤⣞⣁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⢀⣤⣴⣿⣏⠁⠀⠀⠸⣏⢯⣷⣖⣦⡀⠀⠀⠀⠀⠀⠀\n⢀⣾⣽⣿⣿⣿⣿⠛⢲⣶⣾⢉⡷⣿⣿⠵⣿⠀⠀⠀⠀⠀⠀\n⣼⣿⠍⠉⣿⡭⠉⠙⢺⣇⣼⡏⠀⠀ ⠀⣄⢸⠀⠀⠀⠀⠀⠀`", "⠀⠀⠀⣠⣶⡾⠏⠉⠙⠳⢦⡀⠀⠀⠀⢠⠞⠉⠙⠲⡀⠀\n ⠀⣴⠿⠏⠀⠀     ⠀   ⢳⡀⠀⡏⠀⠀    ⠀  ⢷\n⢠⣟⣋⡀⢀⣀⣀⡀⠀⣀⡀   ⣧⠀⢸⠀   ⠀     ⡇\n⢸⣯⡭⠁⠸⣛⣟⠆⡴⣻⡲    ⣿  ⣸  Fursat  ⡇\n ⣟⣿⡭⠀⠀⠀⠀⠀⢱⠀        ⣿  ⢹⠀          ⡇\n  ⠙⢿⣯⠄⠀⠀⠀__ ⠀  ⠀   ⡿ ⠀⡇⠀⠀⠀⠀    ⡼\n⠀⠀⠀⠹⣶⠆⠀⠀⠀⠀⠀⡴⠃⠀   ⠘⠤⣄⣠⠞⠀\n⠀⠀⠀⠀⢸⣷⡦⢤⡤⢤⣞⣁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⢀⣤⣴⣿⣏⠁⠀⠀⠸⣏⢯⣷⣖⣦⡀⠀⠀⠀⠀⠀⠀\n⢀⣾⣽⣿⣿⣿⣿⠛⢲⣶⣾⢉⡷⣿⣿⠵⣿⠀⠀⠀⠀⠀⠀\n⣼⣿⠍⠉⣿⡭⠉⠙⢺⣇⣼⡏⠀⠀ ⠀⣄⢸⠀⠀⠀⠀⠀⠀`", "⠀⠀⠀⣠⣶⡾⠏⠉⠙⠳⢦⡀⠀⠀⠀⢠⠞⠉⠙⠲⡀⠀\n ⠀⣴⠿⠏⠀⠀⠀⠀⠀      ⢳⡀⠀⡏⠀⠀    ⠀  ⢷\n⢠⣟⣋⡀⢀⣀⣀⡀⠀⣀⡀   ⣧⠀⢸⠀⠀ ⠀      ⡇\n⢸⣯⡭⠁⠸⣛⣟⠆⡴⣻⡲    ⣿  ⣸  Meeee   ⡇\n ⣟⣿⡭⠀⠀⠀⠀⠀⢱⠀⠀       ⣿  ⢹⠀          ⡇\n  ⠙⢿⣯⠄⠀⠀|__| ⠀    ⡿ ⠀⡇⠀⠀⠀⠀    ⡼\n⠀⠀⠀⠹⣶⠆⠀⠀⠀⠀⠀⡴⠃⠀   ⠘⠤⣄⣠⠞⠀\n⠀⠀⠀⠀⢸⣷⡦⢤⡤⢤⣞⣁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⢀⣤⣴⣿⣏⠁⠀⠀⠸⣏⢯⣷⣖⣦⡀⠀⠀⠀⠀⠀⠀\n⢀⣾⣽⣿⣿⣿⣿⠛⢲⣶⣾⢉⡷⣿⣿⠵⣿⠀⠀⠀⠀⠀⠀\n⣼⣿⠍⠉⣿⡭⠉⠙⢺⣇⣼⡏⠀⠀ ⠀⣄⢸⠀⠀⠀⠀⠀⠀`", "⠀⠀⠀⣠⣶⡾⠏⠉⠙⠳⢦⡀⠀⠀⠀⢠⠞⠉⠙⠲⡀⠀\n ⠀⣴⠿⠏⠀⠀⠀⠀   ⠀  ⠀⢳⡀⠀⡏⠀⠀       ⢷\n⢠⣟⣋⡀⢀⣀⣀⡀⠀⣀⡀   ⣧⠀⢸⠀  ⠀       ⡇\n⢸⣯⡭⠁⠸⣛⣟⠆⡴⣻⡲   ⣿  ⣸   Nikal   ⡇\n ⣟⣿⡭⠀⠀⠀⠀⠀⢱⠀       ⣿  ⢹⠀           ⡇\n  ⠙⢿⣯⠄⠀⠀lodu⠀⠀   ⡿ ⠀⡇⠀⠀⠀⠀   ⡼\n⠀⠀⠀⠹⣶⠆⠀⠀⠀⠀⠀  ⡴⠃⠀   ⠘⠤⣄⣠⠞⠀\n⠀⠀⠀⠀⢸⣷⡦⢤⡤⢤⣞⣁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⢀⣤⣴⣿⣏⠁⠀⠀⠸⣏⢯⣷⣖⣦⡀⠀⠀⠀⠀⠀⠀\n⢀⣾⣽⣿⣿⣿⣿⠛⢲⣶⣾⢉⡷⣿⣿⠵⣿⠀⠀⠀⠀⠀⠀\n⣼⣿⠍⠉⣿⡭⠉⠙⢺⣇⣼⡏⠀⠀ ⠀⣄⢸⠀"
        ];

        // Send the initial loading message
        for (const asciiMessage of asciiMessages) {
            await new Promise(resolve => setTimeout(resolve, 500)); // Delay for 500ms second
            await conn.relayMessage(
                from,
                {
                    protocolMessage: {
                        key: loadingMessage.key,
                        type: 14,
                        editedMessage: {
                            conversation: asciiMessage,
                        },
                    },
                },
                {}
            );
        }
    } catch (e) {
        console.log(e);
        reply(`❌ *Error!* ${e.message}`);
    }
});

// > JawadTechX 







cmd({
    pattern: "owner",
    desc: "To check ping",
    category: "main",
    react: "👤",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{

const vcard = 'BEGIN:VCARD\n'
            + 'VERSION:3.0\n' 
            + 'FN:Didula Rashmika\n'
            + 'ORG:Didula MD V2;\n'
            + 'TEL;type=CELL;type=VOICE;waid=94741671668:+94 741 671 668\n'
            + 'TEL;type=CELL;type=VOICE;waid=94771820962:+94 771 820 962\n'
            + 'END:VCARD'

await conn.sendMessage(from, { 
    contacts: { 
        displayName: 'Didula Rashmika', 
        contacts: [{ vcard }] 
    }
},{quoted:mek})

await conn.sendMessage(from,{image:{url: 'https://files.catbox.moe/za6ytm.jpg'},caption: `*👤 Didula MD V2 Owner Details*\n\n*👨‍💻 Owner Name:* Didula Rashmika\n*📱 Owner Number:* wa.me/94741671668\n*📱 Owner Number:* wa.me/94771820962\n\n\n*💫 Thanks For Using Didula MD V2*`},{quoted:mek})

} catch (e) {
    reply(e)
    }
})





cmd({
    pattern: "repo",
    desc: "repo the bot",
    react: "📡",
    category: "main",
    filename: __filename
},
async(conn, mek, m, {from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
    try {
        let dec = `*DIDULA MD V2 NEW UPDATE✅*

*⭕ REPO URL*
\`\`\`https://github.com/itsme-didulabot/Didula-MD-V2\`\`\`

*⭕ GET SESSION ID*
\`\`\`https://prabath-md-pair-web-v2-slk.koyeb.app/pair\`\`\`

*⭕ HEROKU DEPLOY*
\`\`\`https://dashboard.heroku.com/new-app?template=https://github.com/itsme-didulabot/Didula-MD-V2\`\`\`

*Deploy Video ✅*

https://youtu.be/AtjXpHEwyKg?si=iLIxkkr4ujCu72cj


SPECIAL FEATURES 👀

> Chanel working
> Heart React
> Anti Bug Message
> Anti Bad/Bot/Link/Call
> AI Chat
> Auto Status Seen React and Reply
> Anti Once View
> Send Status to reply
> Anti Delete
> Commands 100+

*AUTO PLUGIN UPDATE*

📥FOLLOW FOR UPDATE
https://whatsapp.com/channel/0029VaqqF4GDTkJwKruLSK2f`;

        await conn.sendMessage(from, {
            image: {url: 'https://files.catbox.moe/za6ytm.jpg'},
            caption: dec
        }, {quoted: mek});

    } catch(e) {
        console.log(e);
        reply(`${e}`);
    }
});